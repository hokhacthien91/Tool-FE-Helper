<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), clipboard-write=(), display-capture=(), local-network-access=()" />
    <title>Design Review ‚Äî Professional QA Checker</title>
    <!-- 58, 46, 36, 30, 24, 20, 16, 14 -->
    <!-- auto, 103, 104, 106, 107, 108, 110,130, 163 -->
    <style>
        * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  margin: 0;
  padding: 0;
  background: #f5f5f7;
  color: #1d1d1f;
  font-size: 13px;
  line-height: 1.5;
  overflow-x: hidden;
}

#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  max-height: 100vh;
}

.header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 15px 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.header h2 {
  font-size: 18px;
  font-weight: 600;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.controls-group{
  position: relative;
}
.header .subtitle {
  font-size: 12px;
  opacity: 0.9;
  margin-top: 4px;
}

.controls {
  padding: 15px 20px;
  background: white;
  border-bottom: 1px solid #e5e5e7;
  display: flex;
  gap: 16px;
  align-items: center;
  flex-wrap: wrap;
}

.controls-group {
  display: flex;
  gap: 12px;
  align-items: center;
}

.controls-group label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: #1d1d1f;
  cursor: pointer;
  user-select: none;
}

.controls-group input[type="radio"] {
  margin: 0;
  cursor: pointer;
  accent-color: #667eea;
}

#btn-scan, 
#btn-extract-tokens {
  padding: 10px 10px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
  margin-left: auto;
}
#btn-extract-tokens{
    margin-left: 0;
}

#btn-scan:hover,
#btn-extract-tokens:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
}

#btn-scan:active {
  transform: translateY(0);
}

#btn-scan:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

#results {
  flex: 1;
  padding: 15px 20px;
  background: #f5f5f7;
}

#results::-webkit-scrollbar {
  width: 8px;
}

#results::-webkit-scrollbar-track {
  background: #f5f5f7;
}

#results::-webkit-scrollbar-thumb {
  background: #d1d1d6;
  border-radius: 4px;
}

#results::-webkit-scrollbar-thumb:hover {
  background: #a1a1a6;
}

.results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.results-header h3 {
  font-size: 16px;
  font-weight: 600;
  color: #1d1d1f;
}

.results-stats {
  display: flex;
  gap: 12px;
  font-size: 12px;
}

.stat {
  padding: 4px 10px;
  border-radius: 12px;
  font-weight: 600;
}

.stat.error {
  background: #fee;
  color: #c33;
}

.stat.warn {
  background: #fff4e6;
  color: #d97706;
}

.stat.success {
  background: #e6f7f0;
  color: #059669;
}

.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: #86868b;
}

.empty-state.success {
  color: #059669;
}

.empty-state .icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.empty-state p {
  font-size: 14px;
  margin: 0;
}

.scanning {
  text-align: center;
  padding: 40px 20px;
  color: #86868b;
}

.scanning .spinner {
  display: inline-block;
  width: 24px;
  height: 24px;
  border: 3px solid #e5e5e7;
  border-top-color: #667eea;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 12px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.issue-group {
  margin-bottom: 16px;
  background: white;
  border-radius: 8px;
  border: 1px solid #e5e5e7;
  overflow: hidden;
}

.issue-group-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s;
  background: #fafafa;
}

.issue-group-header:hover {
  background: #f5f5f7;
}

.issue-group-header-left {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.issue-group-header h4 {
  font-size: 14px;
  font-weight: 600;
  color: #1d1d1f;
  text-transform: capitalize;
  margin: 0;
  white-space: nowrap;
  flex-shrink: 0;
}

.issue-group-header .badge {
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 11px;
  font-weight: 600;
  background: #e5e5e7;
  color: #1d1d1f;
  white-space: nowrap;
  flex-shrink: 0;
}

.issue-group-toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
  color: #86868b;
  font-size: 16px;
  padding: 0;
}

.issue-group-toggle:hover {
  background: #e5e5e7;
  color: #1d1d1f;
}

.issue-group-toggle-icon {
  transition: transform 0.2s;
  display: inline-block;
}

.issue-group.collapsed .issue-group-toggle-icon {
  transform: rotate(-90deg);
}

.issue-group-content {
  padding: 0 16px 16px 16px;
  transition: opacity 0.2s ease-out;
}

.issue-group:not(.collapsed) .issue-group-content {
  display: block;
  opacity: 1;
}

.issue-group.collapsed .issue-group-content {
  display: none;
  opacity: 0;
}

.issue {
  background: white;
  border-radius: 8px;
  padding: 12px 16px;
  margin-bottom: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
  transition: all 0.2s;
  border-left: 4px solid;
}

.issue:hover {
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
  transform: translateX(2px);
}

.issue.error {
  border-left-color: #ef4444;
  background: #fef2f2;
}

.issue.warn {
  border-left-color: #f59e0b;
  background: #fffbeb;
}

.issue.info {
  border-left-color: #3b82f6;
  background: #eff6ff;
}

.issue-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 12px;
  margin-bottom: 8px;
}

.issue-type {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 2px 8px;
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.05);
  color: #1d1d1f;
  display: flex;
  align-items: center;
  gap: 6px;
}

.issue-number {
  font-weight: 700;
  color: #86868b;
  font-size: 10px;
}

.issue.error .issue-type {
  background: rgba(239, 68, 68, 0.1);
  color: #dc2626;
}

.issue.warn .issue-type {
  background: rgba(245, 158, 11, 0.1);
  color: #d97706;
}

.issue-body {
  font-size: 13px;
  color: #1d1d1f;
  line-height: 1.5;
  margin-bottom: 8px;
}

.issue-node {
  font-size: 12px;
  color: #86868b;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  margin-top: 4px;
}

.issue-actions {
  display: flex;
  gap: 8px;
}

.btn-select {
  padding: 6px 12px;
  border: 1px solid #d1d1d6;
  background: white;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: #1d1d1f;
}

.btn-select:hover {
  background: #f5f5f7;
  border-color: #667eea;
  color: #667eea;
}

.btn-select:active {
  transform: scale(0.98);
}

.footer {
  padding: 15px 20px;
  background: white;
  border-top: 1px solid #e5e5e7;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.footer-left {
  display: flex;
  gap: 8px;
}

.footer-right {
  display: flex;
  gap: 8px;
  align-items: center;
}

.btn-history {
  padding: 8px 16px;
  background: #f5f5f7;
  color: #1d1d1f;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-history:hover {
  background: #e5e5e7;
  border-color: #a1a1a6;
}

/* History Panel */
.history-panel {
  position: fixed;
  top: 0;
  right: 0;
  width: 400px;
  height: 100vh;
  background: white;
  box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
  z-index: 2000;
  display: flex;
  flex-direction: column;
}

.history-header {
  padding: 15px 20px;
  border-bottom: 1px solid #e5e5e7;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #fafafa;
}

.history-header h3 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  color: #1d1d1f;
}

.btn-close-history {
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  color: #86868b;
  font-size: 18px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-close-history:hover {
  background: #e5e5e7;
  color: #1d1d1f;
}

.history-list {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}

.history-item {
  padding: 12px 16px;
  margin-bottom: 8px;
  background: #fafafa;
  border: 1px solid #e5e5e7;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}

.history-item:hover {
  background: #f5f5f7;
  border-color: #d1d1d6;
  transform: translateX(-2px);
}

.history-item-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.history-item-type {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  padding: 2px 8px;
  border-radius: 4px;
  background: #667eea;
  color: white;
}

.history-item-type.issues {
  background: #667eea;
}

.history-item-type.tokens {
  background: #10b981;
}

.history-item-time {
  font-size: 11px;
  color: #86868b;
}

.history-item-info {
  font-size: 12px;
  color: #1d1d1f;
  margin-bottom: 4px;
}

.history-item-stats {
  font-size: 11px;
  color: #86868b;
  display: flex;
  gap: 12px;
}

.history-item-stats span {
  display: flex;
  align-items: center;
  gap: 4px;
}

.history-empty {
  text-align: center;
  padding: 40px 20px;
  color: #86868b;
}

.history-empty .icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.export-group {
  position: relative;
  display: flex;
  align-items: center;
}

.btn-export {
  padding: 8px 16px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
}

.btn-export:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
}

.btn-export:active {
  transform: translateY(0);
}

.export-dropdown {
  position: absolute;
  bottom: 100%;
  left: 0;
  margin-bottom: 8px;
  background: white;
  border: 1px solid #e5e5e7;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  min-width: 180px;
  display: none;
  z-index: 1000;
  overflow: hidden;
}

.export-option {
  display: block;
  width: 100%;
  padding: 12px 16px;
  background: white;
  border: none;
  text-align: left;
  font-size: 13px;
  color: #1d1d1f;
  cursor: pointer;
  transition: background-color 0.2s;
}

.export-option:hover {
  background: #f5f5f7;
}

.export-option:not(:last-child) {
  border-bottom: 1px solid #e5e5e7;
}

#btn-close {
  padding: 8px 16px;
  background: #f5f5f7;
  color: #1d1d1f;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

#btn-close:hover {
  background: #e5e5e7;
  border-color: #a1a1a6;
}

.error-message {
  background: #fef2f2;
  border: 1px solid #fecaca;
  border-radius: 8px;
  padding: 16px;
  color: #dc2626;
  font-size: 13px;
  margin: 20px 20px;
}

.filter-controls {
  padding: 12px 20px;
  background: white;
  border-bottom: 1px solid #e5e5e7;
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.search-box {
  position: relative;
  flex: 1;
  min-width: 200px;
  display: flex;
  align-items: center;
}

.search-input {
  width: 100%;
  padding: 8px 32px 8px 12px;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.2s;
}

.search-input:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.btn-clear-search {
  position: absolute;
  right: 8px;
  top: 7px;
  background: transparent;
  border: none;
  color: #86868b;
  cursor: pointer;
  padding: 4px;
  font-size: 14px;
  line-height: 1;
  border-radius: 4px;
  transition: all 0.2s;
}

.btn-clear-search:hover {
  background: #e5e5e7;
  color: #1d1d1f;
}

.filter-buttons {
  display: flex;
  gap: 8px;
  align-items: center;
}

.filter-btn {
  padding: 6px 12px;
  border: 1px solid #d1d1d6;
  background: white;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: #1d1d1f;
}

.filter-btn:hover {
  background: #f5f5f7;
  border-color: #a1a1a6;
}

.filter-btn.active {
  background: #667eea;
  color: white;
  border-color: #667eea;
}

.color-type-filter {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-type-select {
  padding: 6px 12px;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 12px;
  background: white;
  color: #1d1d1f;
  cursor: pointer;
  transition: all 0.2s;
}

.color-type-select:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Tooltips */
.tooltip {
  position: relative;
  display: inline-block;
}

.tooltip .tooltiptext {
  visibility: hidden;
  width: 200px;
  background-color: #1d1d1f;
  color: white;
  text-align: left;
  border-radius: 6px;
  padding: 8px 12px;
  position: absolute;
  z-index: 1000;
  bottom: 125%;
  left: 50%;
  margin-left: -100px;
  opacity: 0;
  transition: opacity 0.3s;
  font-size: 12px;
  line-height: 1.4;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  pointer-events: none;
}

.tooltip .tooltiptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: #1d1d1f transparent transparent transparent;
}

.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}

.tooltip-right .tooltiptext {
  left: 125%;
  bottom: 50%;
  margin-left: 0;
  margin-bottom: -15px;
}

.tooltip-right .tooltiptext::after {
  top: 50%;
  left: -5px;
  margin-top: -5px;
  margin-left: 0;
  border-color: transparent #1d1d1f transparent transparent;
}

.help-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #e5e5e7;
  color: #86868b;
  font-size: 11px;
  cursor: help;
  margin-left: 4px;
  vertical-align: middle;
}

.help-icon:hover {
  background: #d1d1d6;
  color: #1d1d1f;
}

.token-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-top: 8px;
}

.token-item {
  background: #fafafa;
  border-radius: 6px;
  padding: 10px 12px;
  border: 1px solid #e5e5e7;
  transition: all 0.2s;
}

.token-item:hover {
  background: #f5f5f7;
  border-color: #d1d1d6;
}

.token-item-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.token-value {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
  min-width: 0;
}

.token-number {
  font-weight: 700;
  color: #86868b;
  font-size: 11px;
  margin-right: 4px;
}

.token-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.token-node-count {
  font-size: 11px;
  color: #86868b;
  background: #e5e5e7;
  padding: 2px 6px;
  border-radius: 10px;
  font-weight: 500;
}

.token-node-name {
  font-size: 11px;
  color: #86868b;
  font-style: italic;
  margin-top: 2px;
}

.token-empty-message {
  padding: 12px;
  font-size: 12px;
  color: #9ca3af;
  font-style: italic;
}

.token-note {
  font-size: 11px;
  color: #6b7280;
  margin-top: 4px;
  line-height: 1.4;
}

.token-note-label {
  font-weight: 600;
  color: #4b5563;
  margin-bottom: 2px;
}

.token-note-list {
  margin: 0;
  padding-left: 16px;
}

.token-note-list li {
  margin: 0;
  padding: 0;
}

.token-matched-by-name {
  color: #667eea;
  font-weight: 500;
  font-style: normal;
}

.token-matched-by-name .match-indicator {
  font-size: 10px;
  opacity: 0.8;
  margin-right: 4px;
}

.token-matched-node {
  background: #e0e7ff;
  color: #667eea;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 500;
  font-size: 11px;
}

.token-color-type {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  padding: 2px 6px;
  border-radius: 4px;
  background: #667eea;
  color: white;
  margin-left: 6px;
  letter-spacing: 0.3px;
}

.token-value code {
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  font-size: 12px;
  background: white;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #e5e5e7;
  color: #1d1d1f;
  flex: 1;
  word-break: break-all;
}

.token-color-preview,
.token-gradient-preview {
  width: 32px;
  height: 32px;
  border-radius: 4px;
  border: 1px solid #d1d1d6;
  flex-shrink: 0;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}
/* 
.issue-group-header-left{
    display: flex;
    align-items: center;
    margin: 10px 0;
}
.issue-group-header-left h4 {
    margin: 0;
    padding: 0 5px;
    text-transform: capitalize;
    font-size: 20px;
}
.badge {
    color: red;
}
.issue-group-toggle{
    padding: 0;
    background: transparent;
    border: none;
    box-shadow: none;
}
.issue-group{
    margin: 20px 0;
    background: #ebebeb;
    padding: 10px 15px;
    border-radius: 10px;
} */

    </style>
  </head>
  <body>
    <div id="app">
      <div class="header">
        <h2>
          <span>üé®</span>
          Design Review ‚Äî Professional QA Checker
        </h2>
        <div class="subtitle">Check design quality and extract design tokens with professional standards of Gravity Global.</div>
      </div>

      <div class="controls">
        <div class="controls-group">
          <label class="tooltip">
            <input id="scan-page" type="radio" name="scope" value="page" checked>
            <span>Scan Page</span>
            <span class="tooltiptext">Scan the entire current page to check design issues</span>
          </label>
          <label class="tooltip">
            <input id="scan-selection" type="radio" name="scope" value="selection">
            <span>Scan Selection</span>
            <span class="tooltiptext">Scan only the selected elements in Figma</span>
          </label>
        </div>
     
        <button id="btn-scan" class="tooltip">
          üîç Run Scan Design
          <span class="tooltiptext tooltip-right">Check design according to the standards: naming, auto-layout, spacing, typography, components...</span>
        </button>
        <button id="btn-extract-tokens" class="tooltip">
          üé® Extract Design Tokens
          <span class="tooltiptext tooltip-right">Extract all design tokens: colors, gradients, fonts, spacing, border-radius...</span>
        </button>
      </div>

      <div class="controls-group " style="padding: 10px 20px;">
        <div class="" style="display: flex; gap: 12px; align-items: center; width: 100%;">
          <div class="tooltip" style="flex: 1;">
            <label for="spacing-scale" style="font-size: 12px; color: #86868b; white-space: nowrap; display: block; margin-bottom: 4px;">Spacing Scale:</label>
            <input 
              type="text" 
              id="spacing-scale" 
              placeholder="0, 4, 8, 12, 16, 24, 32, 40, 48, 64, 72, 80, 88, 96" 
              value="0, 4, 8, 12, 16, 24, 32, 40, 48, 64, 72, 80, 88, 96"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e5e5e7; border-radius: 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;"
              class="tooltip"
            >
            <span class="tooltiptext" style="bottom: 65%;">Enter the spacing scale values separated by commas. Leave empty to skip spacing check.</span>
          </div>
          <div class="tooltip" style="flex: 0 0 80px;">
            <label for="spacing-threshold" style="font-size: 12px; color: #86868b; white-space: nowrap; display: block; margin-bottom: 4px;">Threshold:</label>
            <input 
              type="number" 
              id="spacing-threshold" 
              placeholder="100" 
              value="100"
              min="0"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e5e5e7; border-radius: 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;"
              class="tooltip"
            >
            <span class="tooltiptext" style="bottom: 65%;left: 25%;">Threshold: values greater than threshold will pass (special case).</span>
          </div>
        </div>
       
      </div>

      <div class="controls-group " style="padding: 5px 20px;">
        <div class="" style="display: flex; gap: 12px; align-items: center; width: 100%;">
          <div class="tooltip" style="flex: 1;">
            <label for="font-size-scale" style="font-size: 12px; color: #86868b; white-space: nowrap; display: block; margin-bottom: 4px;">Font Size Scale:</label>
            <input 
              type="text" 
              id="font-size-scale" 
              placeholder="32, 24, 20, 18, 16, 14, 12" 
              value="32, 24, 20, 18, 16, 14, 12"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e5e5e7; border-radius: 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;"
              class="tooltip"
            >
            <span class="tooltiptext" style="bottom: 65%;">Enter the font-size scale values separated by commas. Leave empty to skip font-size check.</span>
          </div>
          <div class="tooltip" style="flex: 0 0 80px;">
            <label for="font-size-threshold" style="font-size: 12px; color: #86868b; white-space: nowrap; display: block; margin-bottom: 4px;">Threshold:</label>
            <input 
              type="number" 
              id="font-size-threshold" 
              placeholder="100" 
              value="100"
              min="0"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e5e5e7; border-radius: 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;"
              class="tooltip"
            >
            <span class="tooltiptext" style="bottom: 65%;left: 25%;">Threshold: values greater than threshold will pass (special case).</span>
          </div>
        </div>
       
      </div>

      <div class="controls-group " style="padding: 10px 20px;">
        <div class="" style="display: flex; gap: 12px; align-items: center; width: 100%;">
          <div class="tooltip" style="flex: 1;">
            <label for="line-height-scale" style="font-size: 12px; color: #86868b; white-space: nowrap; display: block; margin-bottom: 4px;">Line Height Scale (%):</label>
            <input 
              type="text" 
              id="line-height-scale" 
              placeholder="auto, 100, 120, 140, 150, 160, 180, 200" 
              value="auto, 100, 120, 140, 150, 160, 180, 200"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e5e5e7; border-radius: 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;"
              class="tooltip"
            >
            <span class="tooltiptext" style="bottom: 65%;">Enter the line-height scale values separated by commas. Leave empty to skip line-height check. The value "auto" is always accepted.</span>
          </div>
          <div class="tooltip" style="flex: 0 0 80px;">
            <label for="line-height-baseline-threshold" style="font-size: 12px; color: #86868b; white-space: nowrap; display: block; margin-bottom: 4px;">Baseline Min (%):</label>
            <input 
              type="number" 
              id="line-height-baseline-threshold" 
              placeholder="120" 
              value="120"
              min="0"
              step="1"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e5e5e7; border-radius: 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;"
              class="tooltip"
            >
            <span class="tooltiptext" style="bottom: 65%;left: 25%;">Baseline threshold: line-height &lt; threshold% will show a warning (e.g. 120% = 1.2x font-size).</span>
          </div>
          <div class="tooltip" style="flex: 0 0 80px;">
            <label for="line-height-threshold" style="font-size: 12px; color: #86868b; white-space: nowrap; display: block; margin-bottom: 4px;">Threshold:</label>
            <input 
              type="number" 
              id="line-height-threshold" 
              placeholder="300" 
              value="300"
              min="0"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e5e5e7; border-radius: 6px; font-size: 12px; font-family: 'SF Mono', Monaco, monospace;"
              class="tooltip"
            >
            <span class="tooltiptext" style="bottom: 65%;left: 25%;">Threshold: values greater than threshold will pass (special case).</span>
          </div>
        
        </div>
       
      </div>
      <div class="filter-controls" id="filter-controls" style="display: none;">
        <div class="search-box tooltip">
          <input type="text" id="search-input" placeholder="üîç Search issues/tokens..." class="search-input">
          <span class="tooltiptext">Search issues and tokens by message, node name, type, or value</span>
          <button id="btn-clear-search" class="btn-clear-search" style="display: none;">‚úï</button>
        </div>
        <div class="filter-buttons" id="filter-buttons">
          <button class="filter-btn active tooltip" data-filter="all">
            All
            <span class="tooltiptext">Show all issues</span>
          </button>
          <button class="filter-btn tooltip" data-filter="error">
            ‚ùå Errors
            <span class="tooltiptext">Show only critical errors (need to fix immediately)</span>
          </button>
          <button class="filter-btn tooltip" data-filter="warn">
            ‚ö†Ô∏è Warnings
            <span class="tooltiptext">Show only warnings (need to fix)</span>
          </button>
        </div>
        <div class="color-type-filter" id="color-type-filter" style="display: none;">
          <select id="color-type-select" class="color-type-select tooltip">
            <option value="all">All Color Types</option>
            <option value="text">Text</option>
            <option value="background">Background</option>
            <option value="border">Border</option>
            <option value="shadow">Shadow</option>
            <option value="fill">Fill</option>
          </select>
        </div>
      </div>

      <div id="results">
        <div class="empty-state">
          <div class="icon">üìã</div>
          <p>No report yet ‚Äî press Run Scan to start checking</p>
        </div>
      </div>

      <div class="footer">
        <div class="footer-left">
          <button id="btn-history" class="btn-history tooltip">
            üìö History
            <span class="tooltiptext tooltip-right">View last 10 scans</span>
          </button>
        </div>
        <div class="footer-right">
          <div class="export-group" style="display: none;" id="export-group">
            <button id="btn-export" class="btn-export">üìÑ Export Report</button>
            <div class="export-dropdown" id="export-dropdown">
              <button class="export-option" data-format="html">üìÑ Export HTML</button>
              <!-- <button class="export-option" data-format="pdf">üìë Export PDF</button> -->
              <button class="export-option" data-format="json">üìã Export JSON</button>
            </div>
          </div>
          <button id="btn-close">Close</button>
      </div>
    </div>

      <!-- History Panel -->
      <div id="history-panel" class="history-panel" style="display: none;">
        <div class="history-header">
          <h3>üìö Scan History</h3>
          <button id="btn-close-history" class="btn-close-history">‚úï</button>
        </div>
        <div id="history-list" class="history-list">
          <!-- History items will be rendered here -->
        </div>
      </div>
    </div>

    <script>
console.log("ui.js loaded");

(function() {
  console.log("Initializing ui.js...");
  const btnScan = document.getElementById("btn-scan");
        const btnExtractTokens = document.getElementById("btn-extract-tokens");
        const btnExport = document.getElementById("btn-export");
        const btnHistory = document.getElementById("btn-history");
        const btnCloseHistory = document.getElementById("btn-close-history");
  const results = document.getElementById("results");
  const btnClose = document.getElementById("btn-close");

        if (!btnScan || !btnExtractTokens || !results || !btnClose || !btnExport || !btnHistory) {
          console.error("Required elements not found", { btnScan, btnExtractTokens, results, btnClose, btnExport, btnHistory });
    return;
  }

        // Store current report data
        let currentReportData = {
          issues: null,
          tokens: null,
          scanMode: null,
          timestamp: null,
          context: null
        };

        function saveLastReport(report) {
          if (!report) return;
          parent.postMessage({ pluginMessage: { type: "save-last-report", report } }, "*");
        }

        function restoreLastReport() {
          parent.postMessage({ pluginMessage: { type: "get-last-report" } }, "*");
        }

        function applySavedReport(saved) {
          if (!saved || !saved.type) {
            console.log("No last report to apply");
            return;
          }

          if (saved.scanMode) {
            const scopeRadio = document.querySelector(`input[name="scope"][value="${saved.scanMode}"]`);
            if (scopeRadio) {
              scopeRadio.checked = true;
            }
          }

          currentReportData.scanMode = saved.scanMode || currentReportData.scanMode;
          currentReportData.context = saved.context || currentReportData.context;

          if (saved.type === "issues" && Array.isArray(saved.issues)) {
            console.log("Applying saved issues report");
            renderResults(saved.issues, true, { skipSave: true, restoreTimestamp: saved.timestamp });
          } else if (saved.type === "tokens" && saved.tokens) {
            console.log("Applying saved tokens report");
            renderTokens(saved.tokens, true, { skipSave: true, restoreTimestamp: saved.timestamp });
          }
        }

        // Filter state
        let currentFilter = "all";
        let currentSearch = "";
        let currentColorTypeFilter = "all";
        let isViewingTokens = false;

  console.log("All elements found, setting up event listeners");

  function clearResults() {
    results.innerHTML = "";
  }

        function getSeverityIcon(severity) {
          if (severity === "error") return "‚ùå";
          if (severity === "warn") return "‚ö†Ô∏è";
          return "‚ÑπÔ∏è";
        }

        function getTypeIcon(type) {
          const icons = {
            naming: "üè∑Ô∏è",
            autolayout: "üìê",
            spacing: "üìè",
            typography: "‚úçÔ∏è",
            "typography-style": "üé®",
            "line-height": "üìù",
            position: "üìç",
            duplicate: "üîÑ",
            group: "üì¶",
            component: "üß©",
            "empty-frame": "üì≠",
            "nested-group": "üìö",
            contrast: "üé®",
            "text-size-mobile": "üì±"
          };
          return icons[type] || "üîç";
        }

        function getTypeDisplayName(type) {
          const displayNames = {
            naming: "Naming Layer",
            autolayout: "Auto Layout",
            spacing: "Spacing",
            typography: "Font Size",
            "typography-style": "Text Style (variable)",
            "line-height": "Line Height",
            position: "Position Layer",
            duplicate: "Duplicate Layer",
            group: "Group Layer",
            component: "Component Reusable",
            "empty-frame": "Empty Frame Layer",
            "nested-group": "Nested Group Layer",
            contrast: "Contrast (ADA AA)",
            "text-size-mobile": "Text Size (ADA)"
          };
          return displayNames[type] || type.replace(/-/g, " ");
        }

        function addIssueEl(issue) {
    const el = document.createElement("div");
          el.className = `issue ${issue.severity}`;
    el.innerHTML = `
      <div class="issue-header">
              <div>
                <span class="issue-type">${getTypeIcon(issue.type)} ${getTypeDisplayName(issue.type)}</span>
      <div class="issue-body">${escapeHtml(issue.message)}</div>
                ${issue.nodeName ? `<div class="issue-node">Node: ${escapeHtml(issue.nodeName)}</div>` : ""}
              </div>
              <div class="issue-actions">
                <button class="btn-select" data-id="${issue.id}">Select</button>
              </div>
      </div>
    `;
    results.appendChild(el);
          const btn = el.querySelector("button.btn-select");
    if (btn) {
      btn.onclick = () => {
        parent.postMessage({ pluginMessage: { type: "select-node", id: issue.id } }, "*");
      };
    }
  }

  function escapeHtml(s) {
    if (!s) return "";
    return s.replace(/[&<>"']/g, function (m) {
      return ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m];
    });
  }

  function getContrastTextColor(hexColor) {
    // Determine if text should be white or black based on background color
    try {
      const r = parseInt(hexColor.slice(1, 3), 16);
      const g = parseInt(hexColor.slice(3, 5), 16);
      const b = parseInt(hexColor.slice(5, 7), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 128 ? "#000000" : "#ffffff";
    } catch (e) {
      return "#000000";
    }
  }

        function filterAndSearchIssues(issues) {
          console.log("filterAndSearchIssues called", { 
            totalIssues: issues.length, 
            currentFilter, 
            currentSearch 
          });
          let filtered = issues;

          // Filter by severity
          if (currentFilter !== "all") {
            filtered = filtered.filter(issue => issue.severity === currentFilter);
            console.log("After severity filter:", filtered.length);
          }

          // Search
          if (currentSearch.trim()) {
            const searchLower = currentSearch.toLowerCase();
            filtered = filtered.filter(issue => {
              const message = (issue.message || "").toLowerCase();
              const nodeName = (issue.nodeName || "").toLowerCase();
              const type = (issue.type || "").toLowerCase();
              return message.includes(searchLower) || 
                     nodeName.includes(searchLower) || 
                     type.includes(searchLower);
            });
            console.log("After search filter:", filtered.length);
          }

          console.log("Final filtered issues:", filtered.length);
          return filtered;
        }

        function renderResults(issues = [], resetFilters = false, options = {}) {
          const { skipSave = false, restoreTimestamp = null } = options;
          // Store report data
          const isNewData = currentReportData.issues !== issues;
          currentReportData.issues = issues;
          currentReportData.tokens = null;
          const timestamp = restoreTimestamp || new Date().toISOString();
          currentReportData.timestamp = timestamp;
          isViewingTokens = false;
          
          // Only reset filters if this is new data or explicitly requested
          if (resetFilters || isNewData) {
            console.log("Resetting filters for new data");
            currentFilter = "all";
            currentColorTypeFilter = "all";
            if (searchInput) {
              searchInput.value = "";
            }
            currentSearch = "";
            if (btnClearSearch) {
              btnClearSearch.style.display = "none";
            }
            if (filterButtons && filterButtons.length > 0) {
              filterButtons.forEach(btn => {
                btn.classList.remove("active");
                if (btn.getAttribute("data-filter") === "all") {
                  btn.classList.add("active");
                }
              });
            }
          }
          
          // Show filter controls
          const filterControls = document.getElementById("filter-controls");
          const colorTypeFilter = document.getElementById("color-type-filter");
          const filterButtonsContainer = document.getElementById("filter-buttons");
          filterControls.style.display = issues.length > 0 ? "flex" : "none";
          colorTypeFilter.style.display = "none";
          filterButtonsContainer.style.display = "flex";
          
          const exportGroup = document.getElementById("export-group");
          exportGroup.style.display = issues.length > 0 ? "flex" : "none";

          // Filter issues - use current filter/search values
          console.log("About to filter with:", { currentFilter, currentSearch });
          const filteredIssues = filterAndSearchIssues(issues);
          
          clearResults();

          if (filteredIssues.length === 0) {
            if (issues.length === 0) {
              results.innerHTML = `
                <div class="empty-state success">
                  <div class="icon">‚úÖ</div>
                  <p><strong>No issues found!</strong></p>
                  <p style="margin-top: 8px; font-size: 12px;">Your design passed all configured checks.</p>
                </div>
              `;
            } else {
              results.innerHTML = `
                <div class="empty-state">
                  <div class="icon">üîç</div>
                  <p><strong>No results found</strong></p>
                  <p style="margin-top: 8px; font-size: 12px;">Try changing the filter or search keyword.</p>
                </div>
              `;
            }
            return;
          }

          // Calculate stats from filtered issues
          const stats = {
            error: filteredIssues.filter(i => i.severity === "error").length,
            warn: filteredIssues.filter(i => i.severity === "warn").length,
            total: filteredIssues.length,
            originalTotal: issues.length
          };

          // Results header
          const header = document.createElement("div");
          header.className = "results-header";
          header.innerHTML = `
            <h3>Check Result</h3>
            <div class="results-stats">
              ${stats.error > 0 ? `<span class="stat error">${stats.error} Error</span>` : ""}
              ${stats.warn > 0 ? `<span class="stat warn">${stats.warn} Warning</span>` : ""}
              <span class="stat">${stats.total} Total</span>
              ${stats.originalTotal !== stats.total ? `<span class="stat" style="opacity: 0.6;">(${stats.originalTotal} total)</span>` : ""}
            </div>
          `;
          results.appendChild(header);

          // Group filtered issues by type
          const grouped = filteredIssues.reduce((acc, i) => {
            acc[i.type] = acc[i.type] || [];
            acc[i.type].push(i);
            return acc;
          }, {});

          // Define all possible issue types (to show even when count = 0)
          const allIssueTypes = [
            "naming", "autolayout", "spacing", "typography", "typography-style", 
            "line-height", "position", "duplicate", "group", "component", 
            "empty-frame", "nested-group", "contrast", "text-size-mobile"
          ];

          // Render all issue types (including those with 0 issues)
          for (const type of allIssueTypes) {
            const issueCount = grouped[type] ? grouped[type].length : 0;
            
            // Skip if no issues and no original issues (first scan)
            if (issueCount === 0 && issues.length === 0) {
              continue; // Don't show empty groups on first scan with no issues
            }
            const groupEl = document.createElement("div");
            groupEl.className = "issue-group collapsed"; // Default collapsed
            
            const groupHeader = document.createElement("div");
            groupHeader.className = "issue-group-header";
            groupHeader.innerHTML = `
              <div class="issue-group-header-left">
                <button class="issue-group-toggle" type="button">
                  <span class="issue-group-toggle-icon">‚ñº</span>
                </button>
                <h4>${getTypeIcon(type)} ${getTypeDisplayName(type)}</h4>
                <span class="badge">${issueCount}</span>
              </div>
            `;
            
            // Add click handler for collapse/expand
            const toggleBtn = groupHeader.querySelector(".issue-group-toggle");
            const toggleCollapse = () => {
              const isCollapsed = groupEl.classList.contains("collapsed");
              if (isCollapsed) {
                groupEl.classList.remove("collapsed");
                groupContent.style.display = "block";
                setTimeout(() => {
                  groupContent.style.opacity = "1";
                }, 10);
              } else {
                groupContent.style.opacity = "0";
                setTimeout(() => {
                  groupEl.classList.add("collapsed");
                  groupContent.style.display = "none";
                }, 200);
              }
            };
            
            toggleBtn.onclick = (e) => {
              e.stopPropagation();
              toggleCollapse();
            };
            
            groupHeader.onclick = (e) => {
              if (e.target !== toggleBtn && !toggleBtn.contains(e.target)) {
                toggleCollapse();
              }
            };
            
            groupEl.appendChild(groupHeader);

            // Create content wrapper - start hidden
            const groupContent = document.createElement("div");
            groupContent.className = "issue-group-content";
            groupContent.style.display = "none"; // Start hidden

            if (issueCount === 0) {
              // Show "No issues" message for empty groups
              const emptyMsg = document.createElement("div");
              emptyMsg.className = "issue info";
              emptyMsg.style.opacity = "0.7";
              emptyMsg.innerHTML = `
                <div class="issue-header">
                  <div>
                    <span class="issue-type">‚úÖ PASSED</span>
                    <div class="issue-body">No issues in this type.</div>
                  </div>
                </div>
              `;
              groupContent.appendChild(emptyMsg);
            } else {
              // Render issues
              grouped[type].forEach((issue, index) => {
              const issueNumber = index + 1;
              const issueEl = document.createElement("div");
              issueEl.className = `issue ${issue.severity}`;
              // Build issue body with additional info for contrast issues
              let issueBody = escapeHtml(issue.message);
              if (issue.type === "contrast") {
                const details = [];
                if (issue.textColor) {
                  details.push(`Text color: <code style="background: ${escapeHtml(issue.textColor)}; padding: 2px 6px; border-radius: 3px; color: ${getContrastTextColor(issue.textColor)};">${escapeHtml(issue.textColor)}</code> (${issue.textColorNode || issue.nodeName || "Unnamed"})`);
                }
                if (issue.backgroundColor) {
                  let bgLabel = "Background:";
                  let bgValue = "";
                  let bgNote = "";
                  
                  if (issue.isGradient && issue.gradientString) {
                    // Show full gradient string
                    bgLabel = `Background (gradient):`;
                    bgValue = `<code style="background: ${escapeHtml(issue.backgroundColor)}; padding: 2px 6px; border-radius: 3px; color: ${getContrastTextColor(issue.backgroundColor)}; font-family: 'SF Mono', Monaco, monospace; font-size: 11px;">${escapeHtml(issue.gradientString)}</code>`;
                    bgNote = " <span style='font-size: 11px; color: #999;'>(average: " + escapeHtml(issue.backgroundColor) + ")</span>";
                  } else {
                    // Show solid color
                    bgValue = `<code style="background: ${escapeHtml(issue.backgroundColor)}; padding: 2px 6px; border-radius: 3px; color: ${getContrastTextColor(issue.backgroundColor)};">${escapeHtml(issue.backgroundColor)}</code>`;
                  }
                  
                  if (issue.fromSibling) {
                    bgNote += " <span style='font-size: 11px; color: #3b82f6;'>(from sibling layer)</span>";
                  }
                  
                  details.push(`${bgLabel} ${bgValue}${bgNote} (${issue.backgroundColorNode || "Unknown"})`);
                }
                if (details.length > 0) {
                  issueBody += `<div style="margin-top: 8px; font-size: 12px; color: #666;">${details.join(" | ")}</div>`;
                }
              }
              
              issueEl.innerHTML = `
                <div class="issue-header">
                  <div>
                    <span class="issue-type">
                      <span class="issue-number">#${issueNumber}</span>
                      ${getSeverityIcon(issue.severity)} ${issue.severity.toUpperCase()}
                    </span>
                    <div class="issue-body">${issueBody}</div>
                    ${issue.nodeName ? `<div class="issue-node">Node: ${escapeHtml(issue.nodeName)}</div>` : ""}
                  </div>
                  <div class="issue-actions">
                    <button class="btn-select" data-id="${issue.id}">Select</button>
                  </div>
                </div>
              `;
              groupContent.appendChild(issueEl);
              
              const btn = issueEl.querySelector("button.btn-select");
              if (btn) {
                btn.onclick = () => {
                  parent.postMessage({ pluginMessage: { type: "select-node", id: issue.id } }, "*");
                };
              }
              });
            }

            groupEl.appendChild(groupContent);
            results.appendChild(groupEl);
          }

          if (!skipSave) {
            saveLastReport({
              type: "issues",
              issues,
              timestamp,
              scanMode: currentReportData.scanMode || null,
              context: currentReportData.context || null
            });
          }
        }

        function filterAndSearchTokens(tokens) {
          console.log("filterAndSearchTokens called", { 
            hasTokens: !!tokens, 
            currentColorTypeFilter, 
            currentSearch 
          });
          if (!tokens) return null;

          const filtered = {};
          let hasMatches = false;
          
          for (const [key, values] of Object.entries(tokens)) {
            let filteredValues = values || [];
            console.log(`Processing ${key}, initial count:`, filteredValues.length);

            // Filter by color type (for colors and gradients)
            if ((key === "colors" || key === "gradients") && currentColorTypeFilter !== "all") {
              filteredValues = filteredValues.filter(token => {
                const colorType = token.colorType || "";
                return colorType.toLowerCase().includes(currentColorTypeFilter.toLowerCase());
              });
              console.log(`After color type filter (${currentColorTypeFilter}):`, filteredValues.length);
            }

            // Search - search in all relevant fields and mark match source
            if (currentSearch.trim()) {
              const searchLower = currentSearch.toLowerCase();
              filteredValues = filteredValues.map(token => {
                const value = String(token.value || "").toLowerCase();
                const nodeNames = (token.nodes || []).map(n => n.name || "").join(" ").toLowerCase();
                const colorType = (token.colorType || "").toLowerCase();
                
                // Check where the match occurs
                const valueMatch = value.includes(searchLower);
                const nodeNameMatch = nodeNames.includes(searchLower);
                const colorTypeMatch = colorType.includes(searchLower);
                
                // If matches, add matchedBy field to indicate why it matched
                if (valueMatch || nodeNameMatch || colorTypeMatch) {
                  const matchedBy = [];
                  if (valueMatch) matchedBy.push("value");
                  if (nodeNameMatch) matchedBy.push("nodeName");
                  if (colorTypeMatch) matchedBy.push("colorType");
                  
                  return {
                    ...token,
                    _matchedBy: matchedBy,
                    _matchedNodeNames: nodeNameMatch ? (token.nodes || []).filter(n => 
                      (n.name || "").toLowerCase().includes(searchLower)
                    ).map(n => n.name) : []
                  };
                }
                return null;
              }).filter(token => token !== null);
              console.log(`After search filter (${key}):`, filteredValues.length);
            }

            if (filteredValues.length > 0) {
              hasMatches = true;
            }

            filtered[key] = filteredValues;
          }

          console.log("Final filtered tokens keys:", Object.keys(filtered));
          return { tokens: filtered, hasMatches };
        }

        function renderTokens(tokens, resetFilters = false, options = {}) {
          const { skipSave = false, restoreTimestamp = null } = options;
          // Store report data
          const isNewData = currentReportData.tokens !== tokens;
          currentReportData.issues = null;
          currentReportData.tokens = tokens;
          const timestamp = restoreTimestamp || new Date().toISOString();
          currentReportData.timestamp = timestamp;
          isViewingTokens = true;
          
          // Only reset filters if this is new data or explicitly requested
          if (resetFilters || isNewData) {
            console.log("Resetting filters for new token data");
            currentFilter = "all";
            currentColorTypeFilter = "all";
            if (searchInput) {
              searchInput.value = "";
            }
            currentSearch = "";
            if (btnClearSearch) {
              btnClearSearch.style.display = "none";
            }
            if (filterButtons && filterButtons.length > 0) {
              filterButtons.forEach(btn => {
                btn.classList.remove("active");
                if (btn.getAttribute("data-filter") === "all") {
                  btn.classList.add("active");
                }
              });
            }
            if (colorTypeSelect) {
              colorTypeSelect.value = "all";
            }
          }
          
          // Show filter controls
          const filterControls = document.getElementById("filter-controls");
          const colorTypeFilter = document.getElementById("color-type-filter");
          const filterButtonsContainer = document.getElementById("filter-buttons");
          filterControls.style.display = tokens && Object.keys(tokens).length > 0 ? "flex" : "none";
          colorTypeFilter.style.display = (tokens && (tokens.colors || tokens.gradients)) ? "block" : "none";
          filterButtonsContainer.style.display = "none"; // Hide severity filter for tokens
          
          const exportGroup = document.getElementById("export-group");
          exportGroup.style.display = tokens && Object.keys(tokens).length > 0 ? "flex" : "none";

          // Filter tokens - use current filter/search values
          console.log("About to filter tokens with:", { currentColorTypeFilter, currentSearch });
          const filterResult = filterAndSearchTokens(tokens);
          
          clearResults();

          if (!tokens || Object.keys(tokens).length === 0) {
            results.innerHTML = `
              <div class="empty-state">
                <div class="icon">üìã</div>
                <p>No design tokens found</p>
              </div>
            `;
            return;
          }

          if (!filterResult) {
            results.innerHTML = `
              <div class="empty-state">
                <div class="icon">üîç</div>
                <p><strong>No results found</strong></p>
                <p style="margin-top: 8px; font-size: 12px;">Try changing the filter or search keyword.</p>
              </div>
            `;
            return;
          }

          const filteredTokens = filterResult.tokens || {};
          const hasTokenMatches = filterResult.hasMatches;
          const isSearchActive = currentSearch.trim() || currentColorTypeFilter !== "all";

          if (isSearchActive && !hasTokenMatches) {
            results.innerHTML = `
              <div class="empty-state">
                <div class="icon">üîç</div>
                <p><strong>No results found</strong></p>
                <p style="margin-top: 8px; font-size: 12px;">Try changing the filter or search keyword.</p>
              </div>
            `;
            return;
          }

            const tokenGroups = {
              colors: { icon: "üé®", label: "Colors", values: filteredTokens.colors || [] },
              gradients: { icon: "üåà", label: "Gradients", values: filteredTokens.gradients || [] },
              borderRadius: { icon: "‚≠ï", label: "Border Radius", values: filteredTokens.borderRadius || [] },
              fontWeight: { icon: "üí™", label: "Font Weight", values: filteredTokens.fontWeight || [] },
              lineHeight: { icon: "üìè", label: "Line Height (%)", values: filteredTokens.lineHeight || [] },
              fontSize: { icon: "üìù", label: "Font Size", values: filteredTokens.fontSize || [] },
              fontFamily: { icon: "üî§", label: "Font Family", values: filteredTokens.fontFamily || [] }
            };

          // Results header
          const header = document.createElement("div");
          header.className = "results-header";
          const totalTokens = Object.values(tokenGroups).reduce((sum, group) => sum + group.values.length, 0);
          header.innerHTML = `
            <h3>Design Tokens</h3>
            <div class="results-stats">
              <span class="stat">${totalTokens} Tokens</span>
            </div>
          `;
          results.appendChild(header);

          // Render token groups
          for (const [key, group] of Object.entries(tokenGroups)) {
            const groupEl = document.createElement("div");
            groupEl.className = "issue-group collapsed"; // Default collapsed
            
            const groupHeader = document.createElement("div");
            groupHeader.className = "issue-group-header";
            groupHeader.innerHTML = `
              <div class="issue-group-header-left">
                <button class="issue-group-toggle" type="button">
                  <span class="issue-group-toggle-icon">‚ñº</span>
                </button>
                <h4>${group.icon} ${group.label}</h4>
                <span class="badge">${group.values.length}</span>
              </div>
            `;
            
            // Create content wrapper - start hidden
            const groupContent = document.createElement("div");
            groupContent.className = "issue-group-content";
            groupContent.style.display = "none";

            // Add click handler for collapse/expand
            const toggleBtn = groupHeader.querySelector(".issue-group-toggle");
            const toggleCollapse = () => {
              const isCollapsed = groupEl.classList.contains("collapsed");
              if (isCollapsed) {
                groupEl.classList.remove("collapsed");
                groupContent.style.display = "block";
                setTimeout(() => {
                  groupContent.style.opacity = "1";
                }, 10);
              } else {
                groupContent.style.opacity = "0";
                setTimeout(() => {
                  groupEl.classList.add("collapsed");
                  groupContent.style.display = "none";
                }, 200);
              }
            };
            
            toggleBtn.onclick = (e) => {
              e.stopPropagation();
              toggleCollapse();
            };
            
            groupHeader.onclick = (e) => {
              if (e.target !== toggleBtn && !toggleBtn.contains(e.target)) {
                toggleCollapse();
              }
            };
            
            groupEl.appendChild(groupHeader);

            const hasValues = Array.isArray(group.values) && group.values.length > 0;

            if (hasValues) {
              const tokenList = document.createElement("div");
              tokenList.className = "token-list";

              group.values.forEach((token, idx) => {
              const tokenNumber = idx + 1;
              const tokenEl = document.createElement("div");
              tokenEl.className = "token-item";
              
              // token is now an object: {value, nodes: [{id, name}], colorType}
              const tokenValue = token.value;
              const nodes = token.nodes || [];
              const firstNode = nodes.length > 0 ? nodes[0] : null;
              const nodeCount = nodes.length;
              const colorType = token.colorType || null;
              
              let valueHtml = "";
              // Special handling for colors
              if (key === "colors") {
                const colorTypeBadge = colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : "";
                valueHtml = `
                  <span class="token-number">#${tokenNumber}</span>
                  <span class="token-color-preview" style="background-color: ${escapeHtml(tokenValue)}"></span>
                  <code>${escapeHtml(tokenValue)}</code>
                  ${colorTypeBadge}
                `;
              } else if (key === "gradients") {
                const colorTypeBadge = colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : "";
                valueHtml = `
                  <span class="token-number">#${tokenNumber}</span>
                  <span class="token-gradient-preview" style="background: ${escapeHtml(tokenValue)}"></span>
                  <code>${escapeHtml(tokenValue)}</code>
                  ${colorTypeBadge}
                `;
              } else {
                valueHtml = `<span class="token-number">#${tokenNumber}</span><code>${escapeHtml(String(tokenValue))}</code>`;
              }
              
              // Check if this token matched by node name in search
              const matchedBy = token._matchedBy || [];
              const matchedNodeNames = token._matchedNodeNames || [];
              const isMatchedByNodeName = matchedBy.includes("nodeName");
              
              // Show matched node names if search matched by node name
              let nodeNameDisplay = "";
              if (firstNode && firstNode.name) {
                if (isMatchedByNodeName && matchedNodeNames.length > 0) {
                  // Highlight matched node names
                  const matchedNamesHtml = matchedNodeNames.map(name => 
                    `<span class="token-matched-node">${escapeHtml(name)}</span>`
                  ).join(", ");
                  nodeNameDisplay = `<div class="token-node-name token-matched-by-name">
                    <span class="match-indicator">üîç Matched in:</span> ${matchedNamesHtml}
                  </div>`;
                } else {
                  nodeNameDisplay = `<div class="token-node-name">Node: ${escapeHtml(firstNode.name)}</div>`;
                }
              }

              // Extra note for Font Weight: show font-family usage breakdown
              let noteHtml = "";
              if (key === "fontWeight") {
                const fontFamilies = Array.isArray(token.fontFamilies) ? token.fontFamilies : null;
                let list = fontFamilies;
                if (!list) {
                  // Fallback (older data): compute from nodes
                  const counts = {};
                  nodes.forEach(n => {
                    const fam = (n && n.fontFamily) ? String(n.fontFamily) : "Unknown";
                    counts[fam] = (counts[fam] || 0) + 1;
                  });
                  list = Object.entries(counts)
                    .map(([family, count]) => ({ family, count }))
                    .sort((a, b) => (b.count - a.count) || a.family.localeCompare(b.family));
                }
                if (Array.isArray(list) && list.length > 0) {
                  const items = list
                    .map(x => `<li><code>${escapeHtml(x.family)}</code> (${x.count})</li>`)
                    .join("");
                  noteHtml = `
                    <div class="token-note">
                      <div class="token-note-label">Font-family:</div>
                      <ul class="token-note-list">${items}</ul>
                    </div>
                  `;
                }
              }
              
              tokenEl.innerHTML = `
                <div class="token-item-row">
                  <div class="token-value">
                    ${valueHtml}
                  </div>
                  ${firstNode ? `
                    <div class="token-actions">
                      <button class="btn-select" data-id="${firstNode.id}">Select</button>
                      ${nodeCount > 1 ? `<span class="token-node-count">(${nodeCount})</span>` : ""}
                    </div>
                  ` : ""}
                </div>
                ${nodeNameDisplay}
                ${noteHtml}
              `;
              
              // Add click handler for Select button
              const btn = tokenEl.querySelector("button.btn-select");
              if (btn) {
                btn.onclick = () => {
                  parent.postMessage({ pluginMessage: { type: "select-node", id: firstNode.id } }, "*");
                };
              }
              
                tokenList.appendChild(tokenEl);
              });

              groupContent.appendChild(tokenList);
            } else {
              const emptyMsg = document.createElement("div");
              emptyMsg.className = "token-empty-message";
              emptyMsg.textContent = "No tokens in this group.";
              groupContent.appendChild(emptyMsg);
            }
            groupEl.appendChild(groupContent);
            results.appendChild(groupEl);
          }

          if (!skipSave) {
            saveLastReport({
              type: "tokens",
              tokens,
              timestamp,
              scanMode: currentReportData.scanMode || null,
              context: currentReportData.context || null
            });
          }
  }

  btnScan.onclick = () => {
    console.log("btnScan clicked");
    try {
      clearResults();
      const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";
      const spacingScaleInput = document.getElementById("spacing-scale");
      const spacingThresholdInput = document.getElementById("spacing-threshold");
      const fontSizeScaleInput = document.getElementById("font-size-scale");
      const fontSizeThresholdInput = document.getElementById("font-size-threshold");
      const lineHeightScaleInput = document.getElementById("line-height-scale");
      const lineHeightThresholdInput = document.getElementById("line-height-threshold");
      const lineHeightBaselineThresholdInput = document.getElementById("line-height-baseline-threshold");
      
      let spacingScaleValue = spacingScaleInput ? spacingScaleInput.value.trim() : "";
      const spacingThreshold = spacingThresholdInput ? parseInt(spacingThresholdInput.value, 10) : 100;
      let fontSizeScaleValue = fontSizeScaleInput ? fontSizeScaleInput.value.trim() : "";
      const fontSizeThreshold = fontSizeThresholdInput ? parseInt(fontSizeThresholdInput.value, 10) : 100;
      let lineHeightScaleValue = lineHeightScaleInput ? lineHeightScaleInput.value.trim() : "";
      const lineHeightThreshold = lineHeightThresholdInput ? parseInt(lineHeightThresholdInput.value, 10) : 300;
      const lineHeightBaselineThreshold = lineHeightBaselineThresholdInput ? parseInt(lineHeightBaselineThresholdInput.value, 10) : 120;
      
      // Validate spacing scale format if not empty
      if (spacingScaleValue) {
        const formatRegex = /^\d+(\s*,\s*\d+)*$/;
        if (!formatRegex.test(spacingScaleValue)) {
          results.innerHTML = `<div class="error-message">Error: Spacing scale format is incorrect. Please enter the numbers separated by commas (e.g. 4, 8, 12, 16)</div>`;
          return;
        }
      }
      
      // Validate font-size scale format if not empty
      if (fontSizeScaleValue) {
        const formatRegex = /^\d+(\s*,\s*\d+)*$/;
        if (!formatRegex.test(fontSizeScaleValue)) {
          results.innerHTML = `<div class="error-message">Error: Font-size scale format is incorrect. Please enter the numbers separated by commas (e.g. 32, 24, 20, 18)</div>`;
          return;
        }
      }
      
      // Validate line-height scale format if not empty (allow "auto" keyword)
      if (lineHeightScaleValue) {
        const formatRegex = /^(\s*auto\s*,?\s*)?(\d+(\s*,\s*\d+)*)?$/i;
        if (!formatRegex.test(lineHeightScaleValue)) {
          results.innerHTML = `<div class="error-message">Error: Line-height scale format is incorrect. Please enter "auto" (if you want to accept) and the numbers separated by commas (e.g. auto, 100, 120, 140, 150)</div>`;
          return;
        }
      }
      
      // Validate thresholds
      if (isNaN(spacingThreshold) || spacingThreshold < 0) {
        results.innerHTML = `<div class="error-message">Error: Spacing threshold must be a number >= 0</div>`;
        return;
      }
      
      if (isNaN(fontSizeThreshold) || fontSizeThreshold < 0) {
        results.innerHTML = `<div class="error-message">Error: Font-size threshold must be a number >= 0</div>`;
        return;
      }
      
      if (isNaN(lineHeightThreshold) || lineHeightThreshold < 0) {
        results.innerHTML = `<div class="error-message">Error: Line-height threshold must be a number >= 0</div>`;
        return;
      }
      
      if (isNaN(lineHeightBaselineThreshold) || lineHeightBaselineThreshold < 0) {
        results.innerHTML = `<div class="error-message">Error: Line-height baseline threshold must be a number >= 0</div>`;
        return;
      }
      
      // Don't save to history here - wait for actual results
      
      results.innerHTML = `
        <div class="scanning">
          <div class="spinner"></div>
          <p>Scanning design... Please wait</p>
        </div>
      `;
      btnScan.disabled = true;
      btnExtractTokens.disabled = true;
      currentReportData.scanMode = scope;
      parent.postMessage({ 
        pluginMessage: { 
          type: "scan", 
          mode: scope, 
          spacingScale: spacingScaleValue, 
          spacingThreshold: spacingThreshold,
          fontSizeScale: fontSizeScaleValue,
          fontSizeThreshold: fontSizeThreshold,
          lineHeightScale: lineHeightScaleValue,
          lineHeightThreshold: lineHeightThreshold,
          lineHeightBaselineThreshold: lineHeightBaselineThreshold
        } 
      }, "*");
      console.log("Message sent:", { type: "scan", mode: scope });
    } catch (error) {
      console.error("Error in btnScan.onclick:", error);
      results.innerHTML = `<div class="error-message">Error: ${escapeHtml(error.message)}</div>`;
      btnScan.disabled = false;
      btnExtractTokens.disabled = false;
    }
  };

  btnExtractTokens.onclick = () => {
    console.log("btnExtractTokens clicked");
    try {
      clearResults();
      const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";
      
      // Don't save to history here - wait for actual results
      
      results.innerHTML = `
        <div class="scanning">
          <div class="spinner"></div>
          <p>Extracting design tokens... Please wait</p>
        </div>
      `;
      btnScan.disabled = true;
      btnExtractTokens.disabled = true;
      currentReportData.scanMode = scope;
      parent.postMessage({ pluginMessage: { type: "extract-tokens", mode: scope } }, "*");
      console.log("Message sent:", { type: "extract-tokens", mode: scope });
    } catch (error) {
      console.error("Error in btnExtractTokens.onclick:", error);
      results.innerHTML = `<div class="error-message">Error: ${escapeHtml(error.message)}</div>`;
      btnScan.disabled = false;
      btnExtractTokens.disabled = false;
    }
  };

        // Export functions
        function generateHTMLReport() {
          const { issues, tokens, timestamp } = currentReportData;
          const date = new Date(timestamp).toLocaleString('vi-VN');
          const pageName = "Design Review"; // Could get from Figma API if needed
          
          let html = `<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Design Review Report - ${date}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      color: #1d1d1f;
      background: #f5f5f7;
      padding: 40px 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 40px;
    }
    .header {
      border-bottom: 2px solid #e5e5e7;
      padding-bottom: 20px;
      margin-bottom: 30px;
    }
    .header h1 {
      font-size: 28px;
      color: #1d1d1f;
      margin-bottom: 8px;
    }
    .header .meta {
      color: #86868b;
      font-size: 14px;
    }
    .section {
      margin-bottom: 40px;
    }
    .section-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #1d1d1f;
      padding-bottom: 8px;
      border-bottom: 1px solid #e5e5e7;
    }
    .export-filter-group {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .export-filter-btn {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      cursor: pointer;
    }
    .export-filter-btn.active {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }
    .stats {
      display: flex;
      gap: 16px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    .stat-card {
      padding: 16px 20px;
      border-radius: 8px;
      background: #f5f5f7;
      min-width: 120px;
    }
    .stat-card.error { background: #fee; color: #c33; }
    .stat-card.warn { background: #fff4e6; color: #d97706; }
    .stat-card .value {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .stat-card .label {
      font-size: 12px;
      text-transform: uppercase;
      opacity: 0.8;
    }
    .issue-group {
      margin-bottom: 24px;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      padding: 16px;
      background: #fff;
    }
    .issue-group-header {
      font-size: 16px;
      font-weight: 600;
      color: #1d1d1f;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
    }
    .issue-group-toggle {
      border: none;
      background: #f3f4f6;
      width: 24px;
      height: 24px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .issue-group-content {
      margin-top: 12px;
    }
    .issue-group.collapsed .issue-group-content {
      display: none;
    }
    .issue {
      padding: 12px 16px;
      margin-bottom: 8px;
      border-radius: 6px;
      border-left: 4px solid;
    }
    .issue.error {
      background: #fef2f2;
      border-left-color: #ef4444;
    }
    .issue.warn {
      background: #fffbeb;
      border-left-color: #f59e0b;
    }
    .issue-type {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .issue-message {
      font-size: 14px;
      margin-bottom: 4px;
    }
    .issue-node {
      font-size: 12px;
      color: #86868b;
      font-family: monospace;
      margin-top: 4px;
    }
    .token-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 12px;
    }
    .token-item {
      padding: 12px;
      background: #fafafa;
      border-radius: 6px;
      border: 1px solid #e5e5e7;
    }
    .token-value {
      font-family: monospace;
      font-size: 13px;
      margin-bottom: 4px;
    }
    .token-color-preview {
      display: inline-block;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #d1d1d6;
      vertical-align: middle;
      margin-right: 8px;
    }
    .token-color-type {
      display: inline-block;
      font-size: 10px;
      padding: 2px 6px;
      background: #667eea;
      color: white;
      border-radius: 4px;
      margin-left: 6px;
    }
    .token-node-count {
      font-size: 11px;
      color: #86868b;
      margin-top: 4px;
    }
    .token-empty-message {
      padding: 12px;
      font-size: 12px;
      color: #9ca3af;
      font-style: italic;
    }
    @media print {
      body { padding: 20px; }
      .container { box-shadow: none; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé® Design Review Report</h1>
      <div class="meta">Generated: ${date} | Page: ${pageName}</div>
    </div>`;

          if (issues && issues.length > 0) {
            const stats = {
              error: issues.filter(i => i.severity === "error").length,
              warn: issues.filter(i => i.severity === "warn").length,
              total: issues.length
            };

            const grouped = issues.reduce((acc, i) => {
              acc[i.type] = acc[i.type] || [];
              acc[i.type].push(i);
              return acc;
            }, {});

            html += `
    <div class="section">
      <h2 class="section-title">üìä Summary</h2>
      <div class="stats">
        ${stats.error > 0 ? `<div class="stat-card error"><div class="value">${stats.error}</div><div class="label">Errors</div></div>` : ''}
        ${stats.warn > 0 ? `<div class="stat-card warn"><div class="value">${stats.warn}</div><div class="label">Warnings</div></div>` : ''}
        <div class="stat-card"><div class="value">${stats.total}</div><div class="label">Total Issues</div></div>
      </div>
    </div>

    <div class="section">
      <h2 class="section-title">üîç Issues</h2>
      <div class="export-filter-group">
        <button class="export-filter-btn active" data-severity="all">All</button>
        <button class="export-filter-btn" data-severity="error">Errors</button>
        <button class="export-filter-btn" data-severity="warn">Warnings</button>
      </div>`;

            for (const [type, typeIssues] of Object.entries(grouped)) {
              const typeLabel = escapeHtml(getTypeDisplayName(type));
              html += `
      <div class="issue-group collapsed" data-type="${type}" data-label="${typeLabel}">
        <div class="issue-group-header">
          <button class="issue-group-toggle" type="button">+</button>
          <span>${typeLabel} (${typeIssues.length})</span>
        </div>
        <div class="issue-group-content">`;
              
              typeIssues.forEach(issue => {
                html += `
          <div class="issue ${issue.severity}">
            <div class="issue-type">${issue.severity.toUpperCase()}</div>
            <div class="issue-message">${escapeHtml(issue.message)}</div>
            ${issue.nodeName ? `<div class="issue-node">Node: ${escapeHtml(issue.nodeName)}</div>` : ''}
          </div>`;
              });
              
              html += `
        </div>
      </div>`;
            }

            html += `
    </div>`;
          }

          if (tokens) {
            html += `
    <div class="section">
      <h2 class="section-title">üé® Design Tokens</h2>`;

            const tokenGroups = {
              colors: { label: "Colors", values: tokens.colors || [] },
              gradients: { label: "Gradients", values: tokens.gradients || [] },
              borderRadius: { label: "Border Radius", values: tokens.borderRadius || [] },
              fontWeight: { label: "Font Weight", values: tokens.fontWeight || [] },
              lineHeight: { label: "Line Height (%)", values: tokens.lineHeight || [] },
              fontSize: { label: "Font Size", values: tokens.fontSize || [] },
              fontFamily: { label: "Font Family", values: tokens.fontFamily || [] }
            };

            for (const [key, group] of Object.entries(tokenGroups)) {
              html += `
      <div class="issue-group collapsed">
        <div class="issue-group-header">
          <button class="issue-group-toggle" type="button">+</button>
          <span>${group.label} (${group.values.length})</span>
        </div>
        <div class="issue-group-content">`;

              if (!group.values || group.values.length === 0) {
                html += `
          <div class="token-empty-message">No tokens in this group.</div>`;
                html += `
        </div>
      </div>`;
                continue;
              }

              html += `
          <div class="token-list">`;

              group.values.forEach(token => {
                const tokenValue = token.value;
                const nodeCount = token.nodes ? token.nodes.length : 0;
                const colorType = token.colorType || "";

                if (key === "colors") {
                  html += `
          <div class="token-item">
            <div class="token-value">
              <span class="token-color-preview" style="background-color: ${escapeHtml(tokenValue)}"></span>
              ${escapeHtml(tokenValue)}
              ${colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : ''}
            </div>
            ${nodeCount > 1 ? `<div class="token-node-count">Used in ${nodeCount} nodes</div>` : ''}
          </div>`;
                } else if (key === "gradients") {
                  html += `
          <div class="token-item">
            <div class="token-value">
              <span class="token-color-preview" style="background: ${escapeHtml(tokenValue)}"></span>
              ${escapeHtml(tokenValue)}
              ${colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : ''}
            </div>
            ${nodeCount > 1 ? `<div class="token-node-count">Used in ${nodeCount} nodes</div>` : ''}
          </div>`;
                } else {
                  // Special note for Font Weight: include font-family breakdown
                  let extraNote = "";
                  if (key === "fontWeight") {
                    let list = Array.isArray(token.fontFamilies) ? token.fontFamilies : null;
                    if (!list) {
                      const counts = {};
                      const nodes = Array.isArray(token.nodes) ? token.nodes : [];
                      nodes.forEach(n => {
                        const fam = (n && n.fontFamily) ? String(n.fontFamily) : "Unknown";
                        counts[fam] = (counts[fam] || 0) + 1;
                      });
                      list = Object.entries(counts)
                        .map(([family, count]) => ({ family, count }))
                        .sort((a, b) => (b.count - a.count) || a.family.localeCompare(b.family));
                    }
                    if (Array.isArray(list) && list.length > 0) {
                      const items = list
                        .map(x => `${escapeHtml(x.family)} (${x.count})`)
                        .join("<br/>");
                      extraNote = `<div class="token-node-count" style="margin-top: 6px;">Font-family:<br/>${items}</div>`;
                    }
                  }
                  html += `
          <div class="token-item">
            <div class="token-value">${escapeHtml(String(tokenValue))}</div>
            ${nodeCount > 1 ? `<div class="token-node-count">Used in ${nodeCount} nodes</div>` : ''}
            ${extraNote}
          </div>`;
                }
              });

              html += `
          </div>
        </div>
      </div>`;
            }

            html += `
    </div>`;
          }

          html += `
  </div>
  <script>
    (function() {
      function updateGroupState(group, content, toggleBtn) {
        const collapsed = group.classList.contains('collapsed');
        if (collapsed) {
          content.style.display = 'none';
          if (toggleBtn) toggleBtn.textContent = '+';
        } else {
          content.style.display = 'block';
          if (toggleBtn) toggleBtn.textContent = '‚àí';
        }
      }

      function initCollapsibles() {
        document.querySelectorAll('.issue-group').forEach(group => {
          const header = group.querySelector('.issue-group-header');
          const content = group.querySelector('.issue-group-content');
          const toggleBtn = group.querySelector('.issue-group-toggle');
          if (!content || !header) return;

          const toggle = () => {
            group.classList.toggle('collapsed');
            updateGroupState(group, content, toggleBtn);
          };

          if (toggleBtn) {
            toggleBtn.addEventListener('click', e => {
              e.stopPropagation();
              toggle();
            });
          }

          header.addEventListener('click', e => {
            if (toggleBtn && (e.target === toggleBtn || toggleBtn.contains(e.target))) {
              return;
            }
            toggle();
          });

          updateGroupState(group, content, toggleBtn);
        });
      }

      function applySeverityFilter(filter) {
        const buttons = document.querySelectorAll('.export-filter-btn');
        buttons.forEach(btn => {
          const val = btn.getAttribute('data-severity') || 'all';
          btn.classList.toggle('active', val === filter);
        });

        document.querySelectorAll('.issue-group').forEach(group => {
          const issues = group.querySelectorAll('.issue');
          const label = group.getAttribute('data-label') || '';
          let visibleCount = 0;

          issues.forEach(issue => {
            const isError = issue.classList.contains('error');
            const isWarn = issue.classList.contains('warn');
            let show = false;
            if (filter === 'all') show = true;
            else if (filter === 'error') show = isError;
            else if (filter === 'warn') show = isWarn;
            issue.style.display = show ? '' : 'none';
            if (show) visibleCount++;
          });

          const headerCountSpan = group.querySelector('.issue-group-header span:last-child');
          if (headerCountSpan && label) {
            headerCountSpan.textContent = label + ' (' + visibleCount + ')';
          }
        });
      }

      function initExportFilters() {
        const buttons = document.querySelectorAll('.export-filter-btn');
        if (!buttons.length) return;
        let current = 'all';

        buttons.forEach(btn => {
          btn.addEventListener('click', () => {
            const val = btn.getAttribute('data-severity') || 'all';
            current = val;
            applySeverityFilter(current);
          });
        });

        // Initial apply
        applySeverityFilter(current);
      }

      function initExportUI() {
        initCollapsibles();
        initExportFilters();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initExportUI);
      } else {
        initExportUI();
      }
    })();
  <\/script>
</body>
</html>`;

          return html;
        }

        // Scan history management - persisted via clientStorage through main plugin
        const MAX_HISTORY = 10;
        let scanHistoryMemory = [];
        let hasLoadedHistoryOnce = false;

        function saveScanHistory(mode, type, data, context) {
          try {
            if (type === "issues" && (!data.issues || data.issues.length === 0)) {
              console.log("Skipping save - no issues data");
              return;
            }
            if (type === "tokens" && (!data.tokens || Object.keys(data.tokens).length === 0)) {
              console.log("Skipping save - no tokens data");
              return;
            }

            const entry = {
              id: Date.now().toString(),
              mode,
              type,
              timestamp: new Date().toISOString(),
              context: context || null,
              data: {
                issues: data.issues || null,
                tokens: data.tokens || null,
                issuesCount: data.issues ? data.issues.length : 0,
                tokensCount: data.tokens ? Object.keys(data.tokens).reduce((sum, k) => sum + (data.tokens[k]?.length || 0), 0) : 0
              }
            };

            // Optimistically update local memory
            scanHistoryMemory.unshift(entry);
            scanHistoryMemory = scanHistoryMemory.slice(0, MAX_HISTORY);

            const historyPanel = document.getElementById("history-panel");
            if (historyPanel && historyPanel.style.display !== "none") {
              renderScanHistory();
            }

            parent.postMessage({ pluginMessage: { type: "save-history-entry", entry } }, "*");
          } catch (e) {
            console.error("Error saving scan history:", e);
          }
        }

        function requestScanHistory() {
          parent.postMessage({ pluginMessage: { type: "get-history" } }, "*");
        }

        function getScanHistory() {
          return scanHistoryMemory || [];
        }

        function loadLastScanMode() {
          try {
            const history = getScanHistory();
            if (history.length > 0) {
              const lastScan = history[0];
              const radio = document.querySelector(`input[name="scope"][value="${lastScan.mode}"]`);
              if (radio) {
                radio.checked = true;
                console.log("Loaded last scan mode:", lastScan.mode);
              }
            }
          } catch (e) {
            console.error("Error loading last scan mode:", e);
          }
        }

        function loadLastScanMode() {
          try {
            const history = getScanHistory();
            if (history.length > 0) {
              const lastScan = history[0];
              const radio = document.querySelector(`input[name="scope"][value="${lastScan.mode}"]`);
              if (radio) {
                radio.checked = true;
                console.log("Loaded last scan mode:", lastScan.mode);
              }
            }
          } catch (e) {
            console.error("Error loading last scan mode:", e);
          }
        }

        function formatHistoryTime(timestamp) {
          try {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return "Just now";
            if (diffMins < 60) return `${diffMins} minutes ago`;
            if (diffHours < 24) return `${diffHours} hours ago`;
            if (diffDays < 7) return `${diffDays} days ago`;
            
            return date.toLocaleString('en-US', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
          } catch (e) {
            return timestamp;
          }
        }

        function renderScanHistory() {
          const historyList = document.getElementById("history-list");
          if (!historyList) {
            console.error("history-list element not found");
            return;
          }

          const history = getScanHistory();
          console.log("Rendering scan history:", history.length, "entries");

          if (history.length === 0) {
            historyList.innerHTML = `
              <div class="history-empty">
                <div class="icon">üìã</div>
                <p>No scan history</p>
                <p style="font-size: 11px; margin-top: 8px;">Scans will be saved automatically</p>
              </div>
            `;
            return;
          }

          historyList.innerHTML = history.map(entry => {
            const timeStr = formatHistoryTime(entry.timestamp);
            const modeLabel = entry.mode === "page" ? "Page" : "Selection";
            const typeLabel = entry.type === "issues" ? "Issues" : "Tokens";
            const typeClass = entry.type === "issues" ? "issues" : "tokens";
            const contextLabel = (entry.context && entry.context.label) ? entry.context.label : `${modeLabel} scan`;
            
            let statsHtml = "";
            if (entry.type === "issues") {
              const errorCount = entry.data.issues?.filter(i => i.severity === "error").length || 0;
              const warnCount = entry.data.issues?.filter(i => i.severity === "warn").length || 0;
              statsHtml = `
                <span>‚ùå ${errorCount} errors</span>
                <span>‚ö†Ô∏è ${warnCount} warnings</span>
                <span>üìä ${entry.data.issuesCount} total</span>
              `;
            } else {
              statsHtml = `
                <span>üé® ${entry.data.tokensCount} tokens</span>
              `;
            }

            return `
              <div class="history-item" data-id="${entry.id}">
                <div class="history-item-header">
                  <span class="history-item-type ${typeClass}">${typeLabel}</span>
                  <span class="history-item-time">${timeStr}</span>
                </div>
                <div class="history-item-info">${escapeHtml(contextLabel)}</div>
                <div class="history-item-stats">${statsHtml}</div>
              </div>
            `;
          }).join("");

          // Add click handlers
          historyList.querySelectorAll(".history-item").forEach(item => {
            item.onclick = () => {
              const entryId = item.getAttribute("data-id");
              restoreReportFromHistory(entryId);
            };
          });
        }

        function restoreReportFromHistory(entryId) {
          try {
            const history = getScanHistory();
            const entry = history.find(e => e.id === entryId);
            
            if (!entry) {
              alert("Scan history entry not found!");
              return;
            }

            // Set scan mode
            const radio = document.querySelector(`input[name="scope"][value="${entry.mode}"]`);
            if (radio) {
              radio.checked = true;
            }
            currentReportData.scanMode = entry.mode;
            currentReportData.context = entry.context || null;

            // Restore report data
            if (entry.type === "issues" && entry.data.issues) {
              currentReportData.issues = entry.data.issues;
              currentReportData.tokens = null;
              isViewingTokens = false;
              renderResults(entry.data.issues, true, { restoreTimestamp: entry.timestamp });
            } else if (entry.type === "tokens" && entry.data.tokens) {
              currentReportData.issues = null;
              currentReportData.tokens = entry.data.tokens;
              isViewingTokens = true;
              renderTokens(entry.data.tokens, true, { restoreTimestamp: entry.timestamp });
            }

            // Close history panel
            const historyPanel = document.getElementById("history-panel");
            if (historyPanel) {
              historyPanel.style.display = "none";
            }

            console.log("Report restored from history:", entryId);
          } catch (e) {
            console.error("Error restoring report from history:", e);
            alert("Error restoring report: " + e.message);
          }
        }

        function exportReport(format) {
          if (!currentReportData.issues && !currentReportData.tokens) {
            alert("No data to export!");
            return;
          }

          // Format: design-review-report-YYYY-MM-DD-HH-MM-SS
          const now = new Date();
          const year = now.getFullYear();
          const month = String(now.getMonth() + 1).padStart(2, '0');
          const day = String(now.getDate()).padStart(2, '0');
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          const seconds = String(now.getSeconds()).padStart(2, '0');
          const filename = `design-review-report-${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;

          if (format === "html") {
            const html = generateHTMLReport();
            const blob = new Blob([html], { type: "text/html" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${filename}.html`;
            a.click();
            URL.revokeObjectURL(url);
          } else if (format === "pdf") {
            const html = generateHTMLReport();
            
            // Try to open print window
            try {
              const printWindow = window.open("", "_blank");
              
              if (!printWindow) {
                // Popup blocked - fallback to download HTML with print instructions
                alert("Popup blocked. Downloading HTML - you can open the file and select Print to create PDF.");
                const blob = new Blob([html], { type: "text/html" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `${filename}.html`;
                a.click();
                URL.revokeObjectURL(url);
                return;
              }
              
              // Write content to new window
              printWindow.document.open();
              printWindow.document.write(html);
              printWindow.document.close();
              
              // Wait for content to load, then trigger print
              printWindow.onload = () => {
                setTimeout(() => {
                  printWindow.print();
                }, 250);
              };
              
              // Fallback if onload doesn't fire
              setTimeout(() => {
                if (printWindow.document && printWindow.document.readyState === "complete") {
                  printWindow.print();
                }
              }, 500);
              
            } catch (error) {
              console.error("Error opening print window:", error);
              // Fallback: download HTML
              alert("Cannot open print window. Downloading HTML - you can open the file and select Print to create PDF.");
              const blob = new Blob([html], { type: "text/html" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = `${filename}.html`;
              a.click();
              URL.revokeObjectURL(url);
            }
          } else if (format === "json") {
            const json = JSON.stringify(currentReportData, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${filename}.json`;
            a.click();
            URL.revokeObjectURL(url);
          }
        }

        // Export button handlers
        const exportGroup = document.getElementById("export-group");
        const exportDropdown = document.getElementById("export-dropdown");
        
        btnExport.onclick = (e) => {
          e.stopPropagation();
          exportDropdown.style.display = exportDropdown.style.display === "block" ? "none" : "block";
        };

        document.querySelectorAll(".export-option").forEach(btn => {
          btn.onclick = (e) => {
            e.stopPropagation();
            const format = btn.getAttribute("data-format");
            exportReport(format);
            exportDropdown.style.display = "none";
          };
        });

        // Close dropdown when clicking outside
        document.addEventListener("click", (e) => {
          if (!exportGroup.contains(e.target)) {
            exportDropdown.style.display = "none";
          }
        });

  // Filter and search handlers - setup after DOM is ready
  let searchInput, btnClearSearch, filterButtons, colorTypeSelect;

  function applyFilters() {
    console.log("applyFilters called", { 
      isViewingTokens, 
      hasTokens: !!currentReportData.tokens, 
      hasIssues: !!currentReportData.issues,
      currentFilter,
      currentSearch,
      currentColorTypeFilter
    });
    if (isViewingTokens && currentReportData.tokens) {
      console.log("Applying filters to tokens");
      renderTokens(currentReportData.tokens, false); // Don't reset filters
    } else if (currentReportData.issues) {
      console.log("Applying filters to issues");
      renderResults(currentReportData.issues, false); // Don't reset filters
    }
  }

  function setupFilterHandlers() {
    console.log("setupFilterHandlers called");
    searchInput = document.getElementById("search-input");
    btnClearSearch = document.getElementById("btn-clear-search");
    filterButtons = document.querySelectorAll(".filter-btn");
    colorTypeSelect = document.getElementById("color-type-select");

    console.log("Elements found:", {
      searchInput: !!searchInput,
      btnClearSearch: !!btnClearSearch,
      filterButtons: filterButtons ? filterButtons.length : 0,
      colorTypeSelect: !!colorTypeSelect
    });

    if (!searchInput || !btnClearSearch || !filterButtons || filterButtons.length === 0) {
      console.warn("Filter elements not found, retrying...", {
        searchInput: !!searchInput,
        btnClearSearch: !!btnClearSearch,
        filterButtons: filterButtons ? filterButtons.length : 0
      });
      setTimeout(setupFilterHandlers, 100);
      return;
    }

    // Search input handler
    console.log("Setting up search input handler");
    searchInput.addEventListener("input", (e) => {
      const newValue = e.target.value;
      console.log("Search input changed:", newValue);
      currentSearch = newValue;
      console.log("currentSearch set to:", currentSearch);
      if (btnClearSearch) {
        btnClearSearch.style.display = currentSearch.trim() ? "block" : "none";
      }
      applyFilters();
    });

    // Clear search button
    if (btnClearSearch) {
      console.log("Setting up clear search button handler");
      btnClearSearch.onclick = (e) => {
        console.log("Clear search clicked");
        e.preventDefault();
        e.stopPropagation();
        if (searchInput) {
          searchInput.value = "";
        }
        currentSearch = "";
        btnClearSearch.style.display = "none";
        applyFilters();
      };
    }

    // Filter buttons handler - toggle behavior
    console.log("Setting up filter buttons handlers, count:", filterButtons.length);
    filterButtons.forEach((btn, index) => {
      console.log(`Setting up filter button ${index}:`, btn.getAttribute("data-filter"));
      btn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const filterValue = btn.getAttribute("data-filter");
        const isCurrentlyActive = btn.classList.contains("active");
        console.log("Filter button clicked:", filterValue, "isActive:", isCurrentlyActive);
        
        if (isCurrentlyActive && filterValue !== "all") {
          // If clicking an active button (except "all"), toggle it off and set to "all"
          btn.classList.remove("active");
          currentFilter = "all";
          // Activate "all" button
          filterButtons.forEach(b => {
            if (b.getAttribute("data-filter") === "all") {
              b.classList.add("active");
            }
          });
        } else {
          // Normal behavior: activate clicked button
          filterButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          currentFilter = filterValue;
        }
        
        console.log("currentFilter set to:", currentFilter);
        applyFilters();
      };
    });

    // Color type filter handler
    if (colorTypeSelect) {
      console.log("Setting up color type select handler");
      colorTypeSelect.addEventListener("change", (e) => {
        console.log("Color type changed:", e.target.value);
        currentColorTypeFilter = e.target.value;
        applyFilters();
      });
    }

    console.log("Filter handlers setup complete");
  }

  // Setup handlers when DOM is ready
  console.log("Setting up filter handlers, DOM readyState:", document.readyState);
  if (document.readyState === "loading") {
    console.log("DOM still loading, waiting for DOMContentLoaded");
    document.addEventListener("DOMContentLoaded", () => {
      console.log("DOMContentLoaded fired, setting up handlers");
      setupFilterHandlers();
      loadLastScanMode(); // Load last scan mode
      restoreLastReport(); // Restore last report if available
      requestScanHistory(); // Fetch persisted history
    });
  } else {
    console.log("DOM already ready, setting up handlers immediately");
    setupFilterHandlers();
    loadLastScanMode(); // Load last scan mode
    restoreLastReport(); // Restore last report if available
    requestScanHistory(); // Fetch persisted history
  }

  // History panel handlers
  if (btnHistory) {
    btnHistory.onclick = () => {
      const historyPanel = document.getElementById("history-panel");
      if (historyPanel) {
        const isVisible = historyPanel.style.display !== "none";
        historyPanel.style.display = isVisible ? "none" : "flex";
        if (!isVisible) {
          renderScanHistory();
        }
      }
    };
  }

  if (btnCloseHistory) {
    btnCloseHistory.onclick = () => {
      const historyPanel = document.getElementById("history-panel");
      if (historyPanel) {
        historyPanel.style.display = "none";
      }
    };
  }

  btnClose.onclick = () => {
    parent.postMessage({ pluginMessage: { type: "close" } }, "*");
  };

  // Receive report from plugin code
  window.onmessage = (event) => {
    console.log("Received message:", event.data);
    const msg = event.data.pluginMessage;

    if (msg && msg.type === "last-report") {
      if (msg.report) {
        applySavedReport(msg.report);
      } else {
        console.log("No last report stored");
      }
      return;
    }

    if (msg && msg.type === "history-data") {
      const history = Array.isArray(msg.history) ? msg.history.slice(0, MAX_HISTORY) : [];
      scanHistoryMemory = history;
      if (!hasLoadedHistoryOnce) {
        loadLastScanMode();
        hasLoadedHistoryOnce = true;
      }
      const historyPanel = document.getElementById("history-panel");
      if (historyPanel && historyPanel.style.display !== "none") {
        renderScanHistory();
      }
      return;
    }

    if (msg && msg.type === "report") {
            btnScan.disabled = false;
            btnExtractTokens.disabled = false;
      const issues = msg.issues || [];
            currentReportData.context = msg.context || null;
            renderResults(issues);
            
            // Save to history after successful scan (with full data)
            const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";
            saveScanHistory(scope, "issues", { issues: issues }, msg.context || null);
          }
          if (msg && msg.type === "tokens-report") {
            btnScan.disabled = false;
            btnExtractTokens.disabled = false;
            if (msg.error) {
              results.innerHTML = `<div class="error-message">Error: ${escapeHtml(msg.error)}</div>`;
            } else {
              currentReportData.context = msg.context || null;
              renderTokens(msg.tokens);
              
              // Save to history after successful extract (with full data)
              const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";
              saveScanHistory(scope, "tokens", { tokens: msg.tokens }, msg.context || null);
      }
    }
  };
})();
    </script>
  </body>
</html>
