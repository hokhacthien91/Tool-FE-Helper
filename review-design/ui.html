<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), clipboard-write=(), display-capture=(), local-network-access=()" />
    <title>Design Review ‚Äî Professional QA Checker</title>
    <!-- 58, 46, 36, 30, 24, 20, 16, 14 -->
    <!-- auto, 103, 104, 106, 107, 108, 110,130, 163 -->
    <style>
        * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  margin: 0;
  padding: 0;
  background: #f5f5f7;
  color: #1d1d1f;
  font-size: 13px;
  line-height: 1.5;
  overflow-x: hidden;
}

#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  max-height: 100vh;
}

.header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 15px 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.header h2 {
  font-size: 18px;
  font-weight: 600;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.controls-group{
  position: relative;
}
.header .subtitle {
  font-size: 12px;
  opacity: 0.9;
  margin-top: 4px;
}

.controls {
  padding: 10px 20px;
  background: white;
  border-bottom: 1px solid #e5e5e7;
  display: flex;
  gap: 16px;
  align-items: center;
  flex-wrap: wrap;
}

.controls-group {
  display: flex;
  gap: 12px;
  align-items: center;
}

.controls-group label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: #1d1d1f;
  cursor: pointer;
  user-select: none;
}
.option-scan label{
  /* font-weight: 700; */
  font-size: 18px;
}
.controls-group input[type="radio"] {
  margin: 0;
  cursor: pointer;
  accent-color: #667eea;
}

#btn-scan, 
#btn-extract-tokens {
  padding: 10px 10px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
}
#btn-extract-tokens{
    margin-left: 0;
}

#btn-scan:hover,
#btn-extract-tokens:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
}

#btn-scan:active {
  transform: translateY(0);
}

#btn-scan:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

#results {
  flex: 1;
  padding: 15px 20px;
  background: #f5f5f7;
}

#results::-webkit-scrollbar {
  width: 8px;
}

#results::-webkit-scrollbar-track {
  background: #f5f5f7;
}

#results::-webkit-scrollbar-thumb {
  background: #d1d1d6;
  border-radius: 4px;
}

#results::-webkit-scrollbar-thumb:hover {
  background: #a1a1a6;
}

.results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.results-header h3 {
  font-size: 16px;
  font-weight: 600;
  color: #1d1d1f;
}

.results-stats {
  display: flex;
  gap: 12px;
  font-size: 12px;
}

.stat {
  padding: 4px 10px;
  border-radius: 12px;
  font-weight: 600;
}

.stat.error {
  background: #fee;
  color: #c33;
}

.stat.warn {
  background: #fff4e6;
  color: #d97706;
}

.stat.success {
  background: #e6f7f0;
  color: #059669;
}

.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: #86868b;
}

.empty-state.success {
  color: #059669;
}

.empty-state .icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.empty-state p {
  font-size: 14px;
  margin: 0;
}

.scanning {
  text-align: center;
  padding: 40px 20px;
  color: #86868b;
}

.scanning .spinner {
  display: inline-block;
  width: 24px;
  height: 24px;
  border: 3px solid #e5e5e7;
  border-top-color: #667eea;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-bottom: 12px;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideOut {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(-10px);
  }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.issue-group {
  margin-bottom: 16px;
  background: white;
  border-radius: 8px;
  border: 1px solid #e5e5e7;
  overflow: hidden;
}

.issue-group-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s;
  background: #fafafa;
}

.issue-group-header:hover {
  background: #f5f5f7;
}

.issue-group-header-left {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 0;
}

.issue-group-header h4 {
  font-size: 14px;
  font-weight: 600;
  color: #1d1d1f;
  text-transform: capitalize;
  margin: 0;
  white-space: nowrap;
  flex-shrink: 0;
}

.issue-group-header .badge {
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 11px;
  font-weight: 600;
  background: #e5e5e7;
  color: #1d1d1f;
  white-space: nowrap;
  flex-shrink: 0;
}

.issue-group-toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
  color: #86868b;
  font-size: 16px;
  padding: 0;
}

.issue-group-toggle:hover {
  background: #e5e5e7;
  color: #1d1d1f;
}

.issue-group-toggle-icon {
  transition: transform 0.2s;
  display: inline-block;
}

.issue-group.collapsed .issue-group-toggle-icon {
  transform: rotate(-90deg);
}

.issue-group-content {
  padding: 0 16px 16px 16px;
  transition: opacity 0.2s ease-out;
}

.issue-group:not(.collapsed) .issue-group-content {
  display: block;
  opacity: 1;
}

.issue-group.collapsed .issue-group-content {
  display: none;
  opacity: 0;
}

.issue {
  background: white;
  border-radius: 8px;
  padding: 12px 16px;
  margin-bottom: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
  transition: all 0.2s;
  border-left: 4px solid;
}

.issue:hover {
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
  transform: translateX(2px);
}

.issue.error {
  border-left-color: #ef4444;
  background: #fef2f2;
}

.issue.warn {
  border-left-color: #f59e0b;
  background: #fffbeb;
}

.issue.info {
  border-left-color: #3b82f6;
  background: #eff6ff;
}

.issue-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 12px;
  margin-bottom: 8px;
}

.issue-type {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 2px 8px;
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.05);
  color: #1d1d1f;
  display: flex;
  align-items: center;
  gap: 6px;
}

.issue-number {
  font-weight: 700;
  color: #86868b;
  font-size: 10px;
}

.issue.error .issue-type {
  background: rgba(239, 68, 68, 0.1);
  color: #dc2626;
}

.issue.warn .issue-type {
  background: rgba(245, 158, 11, 0.1);
  color: #d97706;
}

.issue-body {
  font-size: 13px;
  color: #1d1d1f;
  line-height: 1.5;
  margin-bottom: 8px;
}

.issue-node {
  font-size: 12px;
  color: #86868b;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  margin-top: 4px;
}

.issue-actions {
  display: flex;
  gap: 8px;
}

.btn-select {
  padding: 6px 12px;
  border: 1px solid #d1d1d6;
  background: white;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: #1d1d1f;
}

.btn-select:hover {
  background: #f5f5f7;
  border-color: #667eea;
  color: #667eea;
}

.btn-select:active {
  transform: scale(0.98);
}

.btn-fix {
  padding: 6px 12px;
  border: 1px solid #28a745;
  background: #28a745;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: white;
}

.btn-fix:hover {
  background: #218838;
  border-color: #218838;
}

.btn-fix:active {
  transform: scale(0.98);
}

.btn-create-style {
  padding: 6px 12px;
  border: 1px solid #0071e3;
  background: #0071e3;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: white;
}

.btn-create-style:hover {
  background: #0051a2;
  border-color: #0051a2;
}

.btn-create-style:active {
  transform: scale(0.98);
}

.btn-suggest-apply {
  padding: 6px 12px;
  border: 1px solid #28a745;
  background: #28a745;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: white;
}

.btn-suggest-apply:hover {
  background: #218838;
  border-color: #218838;
}

.btn-suggest-apply:active {
  transform: scale(0.98);
}

.btn-style-dropdown {
  padding: 6px 12px;
  border: 1px solid #0071e3;
  background: white;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: #0071e3;
}

.btn-style-dropdown:hover {
  background: #f0f7ff;
  border-color: #0051a2;
  color: #0051a2;
}

.btn-style-dropdown:active {
  transform: scale(0.98);
}

.style-dropdown-menu {
  font-size: 12px;
}

.style-dropdown-item {
  border-bottom: 1px solid #f0f0f0;
}

.style-dropdown-item:last-child {
  border-bottom: none;
}

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal-dialog {
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  width: 90%;
  max-width: 400px;
  padding: 0;
  position: relative;
  animation: slideInModal 0.3s ease-out;
}

@keyframes slideInModal {
  from {
    opacity: 0;
    transform: translateY(-20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.modal-header {
  padding: 20px 20px 8px 20px;
  position: relative;
}

.modal-close {
  position: absolute;
  top: 16px;
  right: 16px;
  background: none;
  border: none;
  font-size: 20px;
  color: #999;
  cursor: pointer;
  padding: 4px;
  line-height: 1;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.2s;
}

.modal-close:hover {
  background: #f5f5f5;
  color: #333;
}

.modal-title {
  font-size: 16px;
  font-weight: 600;
  color: #1a1a1a;
  margin: 0;
  padding-right: 30px;
}

.modal-subtitle {
  font-size: 13px;
  color: #666;
  margin: 4px 0 0 0;
  padding-right: 30px;
}

.modal-body {
  padding: 16px 20px;
}

.modal-input {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #0071e3;
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  box-sizing: border-box;
  outline: none;
  transition: border-color 0.2s;
}

.modal-input:focus {
  border-color: #0051a2;
  box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.1);
}

.modal-input::placeholder {
  color: #999;
}

.modal-footer {
  padding: 12px 20px 20px 20px;
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

.modal-btn {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  border: 1px solid;
}

.modal-btn-cancel {
  background: white;
  border-color: #ddd;
  color: #333;
}

.modal-btn-cancel:hover {
  background: #f5f5f5;
  border-color: #ccc;
}

.modal-btn-create {
  background: #0071e3;
  border-color: #0071e3;
  color: white;
}

.modal-btn-create:hover {
  background: #0051a2;
  border-color: #0051a2;
}

.modal-btn:active {
  transform: scale(0.98);
}

.btn-fix-all {
  padding: 6px 12px;
  border: 1px solid #28a745;
  background: #28a745;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: white;
  margin-left: auto;
}

.btn-fix-all:hover {
  background: #218838;
  border-color: #218838;
}

.btn-fix-all:active {
  transform: scale(0.98);
}

.btn-add-scale {
  padding: 6px 12px;
  border: 1px solid #667eea;
  background: rgba(102, 126, 234, 0.08);
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  color: #667eea;
  white-space: nowrap;
}

.btn-add-scale:hover {
  background: rgba(102, 126, 234, 0.14);
}

.btn-add-scale:active {
  transform: scale(0.98);
}

.footer {
  padding: 15px 20px;
  background: white;
  border-top: 1px solid #e5e5e7;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.footer-left {
  display: flex;
  gap: 8px;
}

.footer-right {
  display: flex;
  gap: 8px;
  align-items: center;
}

.btn-history {
  padding: 8px 16px;
  background: #f5f5f7;
  color: #1d1d1f;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-history:hover {
  background: #e5e5e7;
  border-color: #a1a1a6;
}

/* History Panel */
.history-panel {
  position: fixed;
  top: 0;
  right: 0;
  width: 400px;
  height: 100vh;
  background: white;
  box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
  z-index: 2000;
  display: flex;
  flex-direction: column;
}

.history-header {
  padding: 15px 20px;
  border-bottom: 1px solid #e5e5e7;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #fafafa;
}

.history-header h3 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  color: #1d1d1f;
}

.btn-close-history {
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  color: #86868b;
  font-size: 18px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-close-history:hover {
  background: #e5e5e7;
  color: #1d1d1f;
}

.history-list {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}

.history-item {
  padding: 12px 16px;
  margin-bottom: 8px;
  background: #fafafa;
  border: 1px solid #e5e5e7;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}

.history-item:hover {
  background: #f5f5f7;
  border-color: #d1d1d6;
  transform: translateX(-2px);
}

.history-item-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.history-item-type {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  padding: 2px 8px;
  border-radius: 4px;
  background: #667eea;
  color: white;
}

.history-item-type.issues {
  background: #667eea;
}

.history-item-type.tokens {
  background: #10b981;
}

.history-item-time {
  font-size: 11px;
  color: #86868b;
}

.history-item-info {
  font-size: 12px;
  color: #1d1d1f;
  margin-bottom: 4px;
}

.history-item-stats {
  font-size: 11px;
  color: #86868b;
  display: flex;
  gap: 12px;
}

.history-item-stats span {
  display: flex;
  align-items: center;
  gap: 4px;
}

.history-empty {
  text-align: center;
  padding: 40px 20px;
  color: #86868b;
}

.history-empty .icon {
  font-size: 48px;
  margin-bottom: 12px;
}

.export-group {
  position: relative;
  display: flex;
  align-items: center;
}

.btn-export {
  padding: 8px 16px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
}

.btn-export:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
}

.btn-export:active {
  transform: translateY(0);
}

.export-dropdown {
  position: absolute;
  bottom: 100%;
  left: 0;
  margin-bottom: 8px;
  background: white;
  border: 1px solid #e5e5e7;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  min-width: 180px;
  display: none;
  z-index: 1000;
  overflow: hidden;
}

.export-option {
  display: block;
  width: 100%;
  padding: 12px 16px;
  background: white;
  border: none;
  text-align: left;
  font-size: 13px;
  color: #1d1d1f;
  cursor: pointer;
  transition: background-color 0.2s;
}

.export-option:hover {
  background: #f5f5f7;
}

.export-option:not(:last-child) {
  border-bottom: 1px solid #e5e5e7;
}

#btn-close {
  padding: 8px 16px;
  background: #f5f5f7;
  color: #1d1d1f;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

#btn-close:hover {
  background: #e5e5e7;
  border-color: #a1a1a6;
}

.error-message {
  background: #fef2f2;
  border: 1px solid #fecaca;
  border-radius: 8px;
  padding: 16px;
  color: #dc2626;
  font-size: 13px;
  margin: 20px 20px;
}

.filter-controls {
  padding: 12px 20px;
  background: white;
  border-bottom: 1px solid #e5e5e7;
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.search-box {
  position: relative;
  flex: 1;
  min-width: 200px;
  display: flex;
  align-items: center;
}

.search-input {
  width: 100%;
  padding: 8px 32px 8px 12px;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 13px;
  transition: all 0.2s;
}

.search-input:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.btn-clear-search {
  position: absolute;
  right: 8px;
  top: 7px;
  background: transparent;
  border: none;
  color: #86868b;
  cursor: pointer;
  padding: 4px;
  font-size: 14px;
  line-height: 1;
  border-radius: 4px;
  transition: all 0.2s;
}

.btn-clear-search:hover {
  background: #e5e5e7;
  color: #1d1d1f;
}

.filter-buttons {
  display: flex;
  gap: 8px;
  align-items: center;
}

.filter-btn {
  padding: 6px 12px;
  border: 1px solid #d1d1d6;
  background: white;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: #1d1d1f;
}

.filter-btn:hover {
  background: #f5f5f7;
  border-color: #a1a1a6;
}

.filter-btn.active {
  background: #667eea;
  color: white;
  border-color: #667eea;
}

.color-type-filter {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-type-select {
  padding: 6px 12px;
  border: 1px solid #d1d1d6;
  border-radius: 6px;
  font-size: 12px;
  background: white;
  color: #1d1d1f;
  cursor: pointer;
  transition: all 0.2s;
}

.color-type-select:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Common utility classes */
.flex-1 {
  flex: 1;
}

.flex-80 {
  flex: 0 0 80px;
}

.flex-row {
  display: flex;
  gap: 12px;
  align-items: center;
  width: 100%;
}

.flex-row-start {
  display: flex;
  gap: 12px;
  align-items: flex-start;
  width: 100%;
}

.control-label {
  font-size: 12px;
  color: #86868b;
  white-space: nowrap;
  display: block;
  margin-bottom: 4px;
}

.control-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e5e5e7;
  border-radius: 6px;
  font-size: 12px;
}

.control-input-mono {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e5e5e7;
  border-radius: 6px;
  font-size: 12px;
  font-family: 'SF Mono', Monaco, monospace;
}

.controls-group-spacing {
  padding: 5px 20px;
  display: block;
}

.controls-group-padding {
  padding: 10px 20px;
  display: block;
}

/* Color Swatch Components */
.color-swatch-container {
  position: relative;
  display: inline-flex;
  flex-direction: column;
  align-items: center;
}

.color-swatch {
  position: relative;
  width: 75px;
  height: 30px;
  border: 1px solid #e5e5e7;
  cursor: default;
  flex-shrink: 0;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.color-swatch-close {
  position: absolute;
  top: -6px;
  right: -6px;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #ff3b30;
  color: white;
  border: 1px solid white;
  font-size: 12px;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  font-weight: bold;
  transition: transform 0.1s;
}

.color-swatch-close:hover {
  transform: scale(1.1);
}

.color-swatch-label {
  text-align: center;
  width: 100%;
  max-width: 75px;
  overflow: hidden;
}

.color-swatch-label-name {
  font-size: 9px;
  font-weight: 600;
  color: #1d1d1f;
  line-height: 1.3;
  margin-bottom: 2px;
}

.color-swatch-label-hex {
  font-size: 8px;
  color: #86868b;
  line-height: 1.2;
  font-family: monospace;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.btn-full-height {
  width: 100%;
  height: 34px;
}

/* Tooltips */
.tooltip {
  position: relative;
  /* display: inline-block; */
}

.tooltip .tooltiptext {
  visibility: hidden;
  width: 200px;
  background-color: #1d1d1f;
  color: white;
  text-align: left;
  border-radius: 6px;
  padding: 8px 12px;
  position: absolute;
  z-index: 1000;
  bottom: 125%;
  left: 50%;
  margin-left: -100px;
  opacity: 0;
  transition: opacity 0.3s;
  font-size: 12px;
  line-height: 1.4;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  pointer-events: none;
}

.tooltip .tooltiptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: #1d1d1f transparent transparent transparent;
}
.tooltip .tooltiptext.left-style{
  left: 0;
  margin-left: 0;
}
.tooltip .tooltiptext.left-style::after {
  left: 45px;
}

.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}

#btn-cancel-scan{
  padding: 10px 10px;
    border: none;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
    margin-left: auto;
    color: #fff;
}

/* Report Tabs */
.report-tabs {
  display: flex;
  gap: 20px;
  margin-bottom: 16px;
  border-bottom: 2px solid #e5e5e7;
  padding: 0 16px;
}

.report-tab {
  padding: 10px 0;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  font-size: 14px;
  font-weight: 500;
  color: #86868b;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  margin-bottom: -2px;
}

.report-tab:hover {
  color: #1d1d1f;
}

.report-tab.active {
  color: #0071e3;
  border-bottom-color: #0071e3;
}

.report-tab .tab-badge {
  display: inline-block;
  margin-left: 8px;
  padding: 2px 8px;
  background: #e5e5e7;
  border-radius: 10px;
  font-size: 11px;
  font-weight: 600;
  color: #1d1d1f;
}

.report-tab.active .tab-badge {
  background: #0071e3;
  color: white;
}

.report-content {
  display: none;
  padding: 10px 20px;
}

.report-content.active {
  display: block;
}

.tooltip-right .tooltiptext {
  left: 125%;
  bottom: 50%;
  margin-left: 0;
  margin-bottom: -15px;
}

.tooltip-right .tooltiptext::after {
  top: 50%;
  left: -5px;
  margin-top: -5px;
  margin-left: 0;
  border-color: transparent #1d1d1f transparent transparent;
}

.help-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #e5e5e7;
  color: #86868b;
  font-size: 11px;
  cursor: help;
  margin-left: 4px;
  vertical-align: middle;
}

.help-icon:hover {
  background: #d1d1d6;
  color: #1d1d1f;
}

.token-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-top: 8px;
}

.token-item {
  background: #fafafa;
  border-radius: 6px;
  padding: 10px 12px;
  border: 1px solid #e5e5e7;
  transition: all 0.2s;
}

.token-item:hover {
  background: #f5f5f7;
  border-color: #d1d1d6;
}

.token-item-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.token-value {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
  min-width: 0;
}

.token-number {
  font-weight: 700;
  color: #86868b;
  font-size: 11px;
  margin-right: 4px;
}

.token-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.token-node-count {
  font-size: 11px;
  color: #86868b;
  background: #e5e5e7;
  padding: 2px 6px;
  border-radius: 10px;
  font-weight: 500;
}

.token-node-name {
  font-size: 11px;
  color: #86868b;
  font-style: italic;
  margin-top: 2px;
}

.token-empty-message {
  padding: 12px;
  font-size: 12px;
  color: #9ca3af;
  font-style: italic;
}

.token-note {
  font-size: 11px;
  color: #6b7280;
  margin-top: 4px;
  line-height: 1.4;
}

.token-note-label {
  font-weight: 600;
  color: #4b5563;
  margin-bottom: 2px;
}

.token-note-list {
  margin: 0;
  padding-left: 16px;
}

.token-note-list li {
  margin: 0;
  padding: 0;
}

.token-matched-by-name {
  color: #667eea;
  font-weight: 500;
  font-style: normal;
}

.token-matched-by-name .match-indicator {
  font-size: 10px;
  opacity: 0.8;
  margin-right: 4px;
}

.token-matched-node {
  background: #e0e7ff;
  color: #667eea;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 500;
  font-size: 11px;
}

.token-color-type {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  padding: 2px 6px;
  border-radius: 4px;
  background: #667eea;
  color: white;
  margin-left: 6px;
  letter-spacing: 0.3px;
}

.token-value code {
  font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
  font-size: 12px;
  background: white;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #e5e5e7;
  color: #1d1d1f;
  flex: 1;
  word-break: break-all;
}

.token-color-preview,
.token-gradient-preview {
  width: 32px;
  height: 32px;
  border-radius: 4px;
  border: 1px solid #d1d1d6;
  flex-shrink: 0;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* Typography Settings Panel */

.typography-panel-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  cursor: pointer;
  user-select: none;
}


.typography-panel.collapsed .typography-panel-content {
  display: none;
}

.typography-panel-content {
  padding: 16px;
  border-top: 1px solid #e5e5e7;
}

.typography-table-wrapper {
  overflow-x: auto;
  margin-bottom: 16px;
}

.typography-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 10px;
}

.typography-table th {
  background: #f5f5f7;
  padding: 5px 6px;
  text-align: left;
  font-weight: 600;
  color: #1d1d1f;
  border-bottom: 2px solid #e5e5e7;
  white-space: nowrap;
}

.typography-table td {
  padding: 5px 6px;
  border-bottom: 1px solid #e5e5e7;
  color: #1d1d1f;
}

.typography-table tbody tr:hover {
  background: #fafafa;
}

.typography-table input,
.typography-table select {
  width: 100%;
  padding: 5px 8px;
  border: 1px solid #d1d1d6;
  border-radius: 4px;
  font-size: 10px;
  font-family: 'SF Mono', Monaco, monospace;
  /* min-width: 100px; */
}

.typography-table input:focus,
.typography-table select:focus {
  outline: none;
  border-color: #667eea;
}

.typography-table-actions {
  display: flex;
  gap: 6px;
  justify-content: center;
}

.btn-table-action {
  padding: 4px 8px;
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: 4px;
  font-size: 16px;
  transition: all 0.2s;
}

.btn-table-action:hover {
  background: #e5e5e7;
}

.btn-table-action.delete:hover {
  background: #fee;
  color: #dc2626;
}

.btn-add-typo-style {
  padding: 8px 16px;
  background: #667eea;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-add-typo-style:hover {
  background: #5568d3;
}

.typography-rules {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 12px;
  background: #fafafa;
  border-radius: 6px;
  margin-bottom: 16px;
}

.typography-rules-title {
  font-size: 12px;
  font-weight: 600;
  color: #1d1d1f;
  margin-bottom: 4px;
}

.typography-rule-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.typography-rule-item input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
}

.typography-rule-item label {
  font-size: 12px;
  color: #1d1d1f;
  cursor: pointer;
  user-select: none;
}

.typography-empty-message {
  text-align: center;
  padding: 20px;
  color: #86868b;
  font-size: 12px;
  font-style: italic;
}
.typography-table-style-name {
  min-width: 220px;
}
.typography-table-font-weight{
  min-width: 135px;
}
.typography-table-font-family{
  min-width: 120px;
}

.controls-group-padding,
.controls-group-spacing,
.typography-panel{
  margin: 5px 20px;
    margin-bottom: 16px;
    background: white;
    border-radius: 8px;
    border: 1px solid #e5e5e7;
    padding: 12px 15px;
}

.mt-10{
  margin-top: 10px;
}
.typography-panel{
  padding: 0;
}

    </style>
  </head>
  <body>
    <div id="app">
      <div class="header">
        <h2>
          <span>üé®</span>
          Design Review ‚Äî Professional QA Checker
        </h2>
        <div class="subtitle">Check design quality and extract design tokens with professional standards of Gravity Global.</div>
      </div>

      <div class="controls">
        <div class="controls-group option-scan">
          <label class="tooltip">
            <input id="scan-page" type="radio" name="scope" value="page" checked>
            <span>Scan Page</span>
            <span class="tooltiptext left-style">Scan the entire current page to check design issues</span>
          </label>
          <label class="tooltip">
            <input id="scan-selection" type="radio" name="scope" value="selection">
            <span>Scan Selection</span>
            <span class="tooltiptext">Scan only the selected elements in Figma</span>
          </label>
        </div>
        </div>
        <div class="controls">
        <button id="btn-scan" class="tooltip">
          üîç Run Scan Design
          <span class="tooltiptext left-style">Check design according to the standards: naming, auto-layout, spacing, typography, components...</span>
        </button>
        <button id="btn-extract-tokens" class="tooltip">
          üé® Extract Design Tokens
          <span class="tooltiptext tooltip-right">Extract all design tokens: colors, gradients, fonts, spacing, border-radius...</span>
        </button>
        <button id="btn-cancel-scan" class="tooltip" style="display: none; background: #b93129;">
          ‚õî Cancel Scan
          <span class="tooltiptext tooltip-right">Stop the current scan operation</span>
        </button>
        <div id="scan-progress" style="display: none; padding: 8px 16px; background: #f5f5f7; border-radius: 8px; margin: 8px 0;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <span style="font-size: 12px; color: #1d1d1f; font-weight: 500;">Scanning...</span>
            <span id="scan-progress-text" style="font-size: 12px; color: #86868b;">0%</span>
          </div>
          <div style="width: 100%; height: 4px; background: #e5e5e7; border-radius: 2px; overflow: hidden;">
            <div id="scan-progress-bar" style="height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s;"></div>
          </div>
        </div>

        <!-- Validation Error Message -->
        <div id="validation-error" style="display: none; padding: 12px 16px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; margin: 8px 0;">
          <div style="display: flex; align-items: start; gap: 8px;">
            <span style="font-size: 18px;">‚ö†Ô∏è</span>
            <div style="flex: 1;">
              <div style="font-weight: 600; color: #856404; margin-bottom: 4px;">Validation Error</div>
              <div id="validation-error-message" style="font-size: 13px; color: #856404; line-height: 1.5;"></div>
            </div>
            <button id="btn-close-validation-error" style="background: transparent; border: none; cursor: pointer; font-size: 18px; color: #856404; padding: 0; line-height: 1;">‚úï</button>
          </div>
        </div>
     
      </div>

      <div class="controls-group controls-group-padding">
        <div class="flex-row">
          <div class="tooltip flex-1">
            <label for="spacing-scale" class="control-label">Spacing (Px):</label>
            <div class="tooltip">
              <input 
              type="text" 
              id="spacing-scale" 
              placeholder="0, 4, 8, 12, 16, 24, 32, 40, 48, 64, 72, 80, 88, 96" 
              value="0, 4, 8, 12, 16, 24, 32, 40, 48, 64, 72, 80, 88, 96"
              class="control-input-mono"
              class="tooltip"
            >
            <span class="tooltiptext" >Enter the spacing guidelines values separated by commas. Leave empty to skip spacing check.</span>
            </div>
          
          </div>
    
          <div class="tooltip flex-80">
            <label for="spacing-threshold" class="control-label">Threshold:</label>
            <div class="tooltip"> <input 
              type="number" 
              id="spacing-threshold" 
              placeholder="100" 
              value="100"
              min="0"
              class="control-input-mono"
              class="tooltip"
            >
            <span class="tooltiptext" style="left: 25%;">Threshold: values greater than threshold will pass (special case).</span></div>
           
          </div>
        </div>
        <div class="flex-row mt-10">
          <div class="tooltip flex-80">
            <button id="btn-fill-spacing-scale" class="btn-add-scale tooltip btn-full-height" disabled>
              Use tokens
            </button>
            <span class="tooltiptext left-style">Replace Spacing Guidelines input with all extracted spacing tokens (unique + sorted). Run ‚ÄúExtract Design Tokens‚Äù first.</span>
          </div>
        </div>
       
      </div>

      <div class="controls-group controls-group-spacing">
        <div class="flex-row">
          <div class="flex-1">
            <label for="color-scale" class="control-label">Color:</label>
            <div class="tooltip">
              <input 
              type="text" 
              id="color-scale" 
              placeholder="#000000, #FFFFFF, #FF0000" 
              value=""
              class="control-input-mono tooltip"
            >
            <span class="tooltiptext">Enter the color values (hex format only, e.g., #000000) separated by commas. Leave empty to skip color check.</span>
            </div>
          
            <!-- Color Preview Swatches -->
            <div id="color-preview" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; min-height: 20px;"></div>
          </div>
      
        </div>
        <div class="flex-row mt-10">
          <div class="tooltip flex-80">
            <button id="btn-fill-color-scale" class="btn-add-scale tooltip btn-full-height" disabled>
              Use tokens
            </button>
            <span class="tooltiptext left-style">Replace Color input with all extracted color tokens (unique + sorted). Run "Extract Design Tokens" first.</span>
          </div>
          <div class="tooltip flex-80">
            <button id="btn-extract-color-styles" class="btn-add-scale tooltip btn-full-height">
              üì• Extract Styles
            </button>
            <span class="tooltiptext">Extract all Color Styles (Paint Styles) from Figma and fill into Color input.</span>
          </div>
          <div class="tooltip flex-80">
            <button id="btn-extract-color-variables" class="btn-add-scale tooltip btn-full-height">
              üìä Extract Variables
            </button>
            <span class="tooltiptext">Extract all Color Variables from Figma and fill into Color input.</span>
          </div>
          </div>
      </div>

      <div class="controls-group controls-group-spacing">
        <div class="flex-row-start">
          <div class="tooltip flex-1">
            <label for="font-size-scale" class="control-label">Font Size (Px):</label>
            <div class="tooltip">
              <input 
              type="text" 
              id="font-size-scale" 
              placeholder="32, 24, 20, 18, 16, 14, 12" 
              value="32, 24, 20, 18, 16, 14, 12"
              class="control-input-mono"
              class="tooltip"
            >
            <span class="tooltiptext" >Enter the font-size scale values separated by commas. Leave empty to skip font-size check.</span>
          </div>
            </div>
           
       
          <div class="tooltip flex-80">
            <label for="font-size-threshold" class="control-label">Threshold:</label>
            <div class="tooltip">
              <input 
              type="number" 
              id="font-size-threshold" 
              placeholder="100" 
              value="100"
              min="0"
              class="control-input-mono"
              class="tooltip"
            >
            <span class="tooltiptext" style="left: 25%;">Threshold: values greater than threshold will pass (special case).</span>
            </div>
          
          </div>
        </div>
        <div class="flex-row-start mt-10">
          <div class="tooltip flex-80">
            <button id="btn-fill-font-size-scale" class="btn-add-scale tooltip btn-full-height" disabled>
              Use tokens
            </button>
            <span class="tooltiptext left-style">Replace Font Size input with all extracted font size tokens (unique + sorted). Run "Extract Design Tokens" first.</span>
          </div>
          <div class="tooltip flex-80">
            <button id="btn-fill-font-size-from-typo" class="btn-add-scale tooltip btn-full-height">
              Use Typography
            </button>
            <span class="tooltiptext">Replace Font Size input with all font sizes from Typography table (unique + sorted).</span>
          </div>
        </div>
       
      </div>

      <div class="controls-group controls-group-padding">
        <div class="flex-row-start">
          <div class="tooltip flex-1">
            <label for="line-height-scale" class="control-label">Line Height (%):</label>
            <div class="tooltip">
              <input 
              type="text" 
              id="line-height-scale" 
              placeholder="auto, 100, 120, 140, 150, 160, 180, 200" 
              value="auto, 100, 120, 140, 150, 160, 180, 200"
              class="control-input-mono"
              class="tooltip"
            >
            <span class="tooltiptext" >Enter the line-height scale values separated by commas. Leave empty to skip line-height check. The value "auto" is always accepted.</span>
            </div>
            
          </div>
         
          <div class="tooltip flex-80">
            <label for="line-height-baseline-threshold" class="control-label">Baseline Min (%):</label>
            <div class="tooltip">
              <input 
              type="number" 
              id="line-height-baseline-threshold" 
              placeholder="120" 
              value="120"
              min="0"
              step="1"
              class="control-input-mono"
              class="tooltip"
            >
            <span class="tooltiptext" style="left: 25%;">Baseline threshold: line-height &lt; threshold% will show a warning (e.g. 120% = 1.2x font-size).</span>
            </div>
           
          </div>
          <div class="tooltip flex-80">
            <label for="line-height-threshold" class="control-label">Threshold:</label>
            <div class="tooltip">
              <input 
              type="number" 
              id="line-height-threshold" 
              placeholder="300" 
              value="300"
              min="0"
              class="control-input-mono"
              class="tooltip"
            >
            <span class="tooltiptext" style="left: 25%;">Threshold: values greater than threshold will pass (special case).</span>
            </div>
           
          </div>
        </div>
        <div class="flex-row-start mt-10">
          <div class="tooltip flex-80">
            <button id="btn-fill-line-height-scale" class="btn-add-scale tooltip btn-full-height" disabled>
              Use tokens
            </button>
            <span class="tooltiptext left-style">Replace Line Height input with all extracted line height tokens (unique + sorted). Run "Extract Design Tokens" first.</span>
          </div>
          <div class="tooltip flex-80">
            <button id="btn-fill-line-height-from-typo" class="btn-add-scale tooltip btn-full-height">
              Use Typography
            </button>
            <span class="tooltiptext">Replace Line Height input with all line heights from Typography table (unique + sorted).</span>
          </div>
        </div>
       
      </div>

      <!-- Typography Settings Panel -->
      <div class="typography-panel collapsed" id="typography-panel">
        <div class="typography-panel-header" id="typography-panel-header">
          <button class="issue-group-toggle" type="button" id="typography-panel-toggle">
            <span class="issue-group-toggle-icon">‚ñ∂</span>
          </button>
          <h4 style="font-size: 14px; font-weight: 600; margin: 0;">‚úçÔ∏è Typography Settings</h4>
          <span style="font-size: 11px; color: #86868b; margin-left: auto;">(Click to expand)</span>
        </div>
        <div class="typography-panel-content">
          <!-- Rule Toggles -->
          <div class="typography-rules">
            <div class="typography-rules-title">Check Rules:</div>
            <div class="typography-rule-item">
              <input type="checkbox" id="rule-typo-style" checked>
              <label for="rule-typo-style">Check Typography Style (match 100% with defined styles)</label>
            </div>
            <div class="typography-rule-item">
              <input type="checkbox" id="rule-font-family" checked>
              <label for="rule-font-family">Check Font Family</label>
            </div>
            <div class="typography-rule-item">
              <input type="checkbox" id="rule-font-size" checked>
              <label for="rule-font-size">Check Font Size</label>
            </div>
            <div class="typography-rule-item">
              <input type="checkbox" id="rule-font-weight" checked>
              <label for="rule-font-weight">Check Font Weight</label>
            </div>
            <div class="typography-rule-item">
              <input type="checkbox" id="rule-line-height" checked>
              <label for="rule-line-height">Check Line Height</label>
            </div>
            <div class="typography-rule-item">
              <input type="checkbox" id="rule-letter-spacing">
              <label for="rule-letter-spacing">Check Letter Spacing</label>
            </div>
            <div class="typography-rule-item">
              <input type="checkbox" id="rule-word-spacing">
              <label for="rule-word-spacing">Check Word Spacing</label>
            </div>
          </div>

          <!-- Typography Styles Table -->
          <div class="typography-table-wrapper">
            <table class="typography-table" id="typography-table">
              <thead>
                <tr>
                  <th class="typography-table-actions">Actions</th>
                  <th class="typography-table-style-name" style="width: 120px;">Style Name</th>
                  <th class="typography-table-font-family" style="width: 140px;">Font Family</th>
                  <th class="typography-table-font-size" style="width: 80px;">Size (px)</th>
                  <th class="typography-table-font-weight" style="width: 100px;">Weight</th>
                  <th class="typography-table-line-height" style="width: 100px;">Line Height</th>
                  <th class="typography-table-letter-spacing" style="width: 100px;">Letter Spacing</th>
                  <th class="typography-table-word-spacing" style="width: 100px;">Word Spacing</th>
                </tr>
              </thead>
              <tbody id="typography-table-body">
                <!-- Rows will be rendered here -->
              </tbody>
            </table>
          </div>

          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn-add-typo-style" id="btn-add-typo-style">
              ‚ûï Add Style
            </button>
            <button class="btn-add-typo-style tooltip" id="btn-extract-typo-desktop" style="background: #28a745;">
              üñ•Ô∏è Desktop
              <span class="tooltiptext" style="width: 250px;">Extract Text Styles for Desktop (e.g., H1, H2, Body)</span>
            </button>
            <button class="btn-add-typo-style tooltip" id="btn-extract-typo-tablet" style="background: #fd7e14;">
              üì± Tablet
              <span class="tooltiptext" style="width: 250px;">Extract Text Styles for Tablet (e.g., H1/Tablet, Body/Tablet)</span>
            </button>
            <button class="btn-add-typo-style tooltip" id="btn-extract-typo-mobile" style="background: #17a2b8;">
              üì± Mobile
              <span class="tooltiptext" style="width: 250px;">Extract Text Styles for Mobile (e.g., H1/Mobile, Body/Mobile)</span>
            </button>
            <button class="btn-add-typo-style tooltip" id="btn-extract-typo-all" style="background: #6c757d;">
              üåê All
              <span class="tooltiptext" style="width: 250px;">Extract all Text Styles (Desktop + Tablet + Mobile)</span>
            </button>
            <button class="btn-add-typo-style tooltip" id="btn-reset-typo-table" style="background: #dc3545;">
              üîÑ Reset
              <span class="tooltiptext" style="width: 200px;">Reset table to default typography styles</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Report Tabs -->
      <div class="report-tabs">
        <button class="report-tab active" data-tab="issues">
          üìã Issues
          <span class="tab-badge" id="issues-count">0</span>
        </button>
        <button class="report-tab" data-tab="tokens">
          üé® Design Tokens
          <span class="tab-badge" id="tokens-count">0</span>
        </button>
      </div>

      <!-- Filter Controls -->
      <div class="filter-controls" id="filter-controls" style="display: none;">
        <div class="search-box tooltip">
          <input type="text" id="search-input" placeholder="üîç Search issues/tokens..." class="search-input">
          <span class="tooltiptext">Search issues and tokens by message, node name, type, or value</span>
          <button id="btn-clear-search" class="btn-clear-search" style="display: none;">‚úï</button>
        </div>
        <div class="filter-buttons" id="filter-buttons">
          <button class="filter-btn active tooltip" data-filter="all">
            All
            <span class="tooltiptext">Show all issues</span>
          </button>
          <button class="filter-btn tooltip" data-filter="error">
            ‚ùå Errors
            <span class="tooltiptext">Show only critical errors (need to fix immediately)</span>
          </button>
          <button class="filter-btn tooltip" data-filter="warn">
            ‚ö†Ô∏è Warnings
            <span class="tooltiptext">Show only warnings (need to fix)</span>
          </button>
        </div>
        <div class="color-type-filter" id="color-type-filter" style="display: none;">
          <select id="color-type-select" class="color-type-select tooltip">
            <option value="all">All Color Types</option>
            <option value="text">Text</option>
            <option value="background">Background</option>
            <option value="border">Border</option>
            <option value="shadow">Shadow</option>
            <option value="fill">Fill</option>
          </select>
        </div>
      </div>

      <!-- Issues Report -->
      <div id="results-issues" class="report-content active">
        <div class="empty-state">
          <div class="icon">üìã</div>
          <p>No issues report yet ‚Äî press Run Scan to start checking</p>
        </div>
      </div>

      <!-- Tokens Report -->
      <div id="results-tokens" class="report-content">
        <div class="empty-state">
          <div class="icon">üé®</div>
          <p>No tokens report yet ‚Äî press Extract Tokens to start</p>
        </div>
      </div>

      <div class="footer">
        <div class="footer-left">
          <button id="btn-history" class="btn-history tooltip">
            üìö History
            <span class="tooltiptext tooltip-right">View last 10 scans</span>
          </button>
          <button id="btn-reset-all" class="btn-history tooltip" style="background: #ff9500; margin-left: 8px;">
            üîÑ Reset All
            <span class="tooltiptext tooltip-right">Reset all settings to default and clear history</span>
          </button>
        </div>
        <div class="footer-right">
          <div class="export-group" style="display: none;" id="export-group">
            <button id="btn-export" class="btn-export">üìÑ Export Report</button>
            <div class="export-dropdown" id="export-dropdown">
              <button class="export-option" data-format="html">üìÑ Export HTML</button>
              <!-- <button class="export-option" data-format="pdf">üìë Export PDF</button> -->
              <button class="export-option" data-format="json">üìã Export JSON</button>
            </div>
          </div>
          <button id="btn-close">Close</button>
      </div>
    </div>

      <!-- History Panel -->
      <div id="history-panel" class="history-panel" style="display: none;">
        <div class="history-header">
          <h3>üìö Scan History</h3>
          <button id="btn-close-history" class="btn-close-history">‚úï</button>
        </div>
        <div id="history-list" class="history-list">
          <!-- History items will be rendered here -->
        </div>
      </div>
    </div>

    <script>
console.log("ui.js loaded");

(function() {
  console.log("Initializing ui.js...");
  const btnScan = document.getElementById("btn-scan");
        const btnCancelScan = document.getElementById("btn-cancel-scan");
        const scanProgress = document.getElementById("scan-progress");
        const scanProgressBar = document.getElementById("scan-progress-bar");
        const scanProgressText = document.getElementById("scan-progress-text");
        const btnExtractTokens = document.getElementById("btn-extract-tokens");
        const btnFillSpacingScale = document.getElementById("btn-fill-spacing-scale");
        const btnFillColorScale = document.getElementById("btn-fill-color-scale");
        const btnExtractColorStyles = document.getElementById("btn-extract-color-styles");
        const btnFillFontSizeScale = document.getElementById("btn-fill-font-size-scale");
        const btnFillLineHeightScale = document.getElementById("btn-fill-line-height-scale");
        const btnFillFontSizeFromTypo = document.getElementById("btn-fill-font-size-from-typo");
        const btnFillLineHeightFromTypo = document.getElementById("btn-fill-line-height-from-typo");
        const btnExport = document.getElementById("btn-export");
        const btnHistory = document.getElementById("btn-history");
        const btnCloseHistory = document.getElementById("btn-close-history");
        const btnResetAll = document.getElementById("btn-reset-all");
  const resultsIssues = document.getElementById("results-issues");
  const resultsTokens = document.getElementById("results-tokens");
  const btnClose = document.getElementById("btn-close");
  
  // Report tabs
  const reportTabs = document.querySelectorAll(".report-tab");
  const reportContents = document.querySelectorAll(".report-content");
  let activeTab = "issues";

        if (!btnScan || !btnExtractTokens || !resultsIssues || !resultsTokens || !btnClose || !btnExport || !btnHistory || !btnFillSpacingScale || !btnFillColorScale || !btnFillFontSizeScale || !btnFillLineHeightScale) {
          console.error("Required elements not found", { btnScan, btnExtractTokens, btnFillSpacingScale, btnFillColorScale, btnFillFontSizeScale, btnFillLineHeightScale, resultsIssues, resultsTokens, btnClose, btnExport, btnHistory });
    return;
  }

        // Store current report data
        // Color name mapping (hex -> name) for tooltips
        let colorNameMap = {};
        
        let currentReportData = {
          issues: null,
          tokens: null,
          scanMode: null,
          timestamp: null,
          tokensTimestamp: null,
          context: null
        };

        // Typography Styles Storage
        let typographyStyles = [
          // Default styles
          { id: 1, name: "H1", fontFamily: "Inter", fontSize: 48, fontWeight: "Bold", lineHeight: "120%", letterSpacing: "0", wordSpacing: "0" },
          { id: 2, name: "H2", fontFamily: "Inter", fontSize: 36, fontWeight: "Bold", lineHeight: "130%", letterSpacing: "0", wordSpacing: "0" },
          { id: 3, name: "H3", fontFamily: "Inter", fontSize: 28, fontWeight: "SemiBold", lineHeight: "130%", letterSpacing: "0", wordSpacing: "0" },
          { id: 4, name: "H4", fontFamily: "Inter", fontSize: 24, fontWeight: "SemiBold", lineHeight: "140%", letterSpacing: "0", wordSpacing: "0" },
          { id: 5, name: "H5", fontFamily: "Inter", fontSize: 20, fontWeight: "Medium", lineHeight: "140%", letterSpacing: "0", wordSpacing: "0" },
          { id: 6, name: "H6", fontFamily: "Inter", fontSize: 18, fontWeight: "Medium", lineHeight: "140%", letterSpacing: "0", wordSpacing: "0" },
          { id: 7, name: "Body", fontFamily: "Inter", fontSize: 16, fontWeight: "Regular", lineHeight: "150%", letterSpacing: "0", wordSpacing: "0" }
        ];
        let nextTypoStyleId = 8;

        function saveLastReport(report) {
          if (!report) return;
          parent.postMessage({ pluginMessage: { type: "save-last-report", report } }, "*");
        }

        function restoreLastReport() {
          parent.postMessage({ pluginMessage: { type: "get-last-report" } }, "*");
        }

        function saveInputValues() {
          const values = {
            spacingScale: document.getElementById("spacing-scale")?.value || "",
            spacingThreshold: document.getElementById("spacing-threshold")?.value || "100",
            colorScale: document.getElementById("color-scale")?.value || "",
            colorNameMap: colorNameMap, // Save color name mapping
            fontSizeScale: document.getElementById("font-size-scale")?.value || "",
            fontSizeThreshold: document.getElementById("font-size-threshold")?.value || "100",
            lineHeightScale: document.getElementById("line-height-scale")?.value || "",
            lineHeightThreshold: document.getElementById("line-height-threshold")?.value || "300",
            lineHeightBaselineThreshold: document.getElementById("line-height-baseline-threshold")?.value || "120",
            typographyStyles: typographyStyles,
            typographyRules: {
              checkStyle: document.getElementById("rule-typo-style")?.checked || true,
              checkFontFamily: document.getElementById("rule-font-family")?.checked || true,
              checkFontSize: document.getElementById("rule-font-size")?.checked || true,
              checkFontWeight: document.getElementById("rule-font-weight")?.checked || true,
              checkLineHeight: document.getElementById("rule-line-height")?.checked || true,
              checkLetterSpacing: document.getElementById("rule-letter-spacing")?.checked || false,
              checkWordSpacing: document.getElementById("rule-word-spacing")?.checked || false
            }
          };
          parent.postMessage({ pluginMessage: { type: "save-input-values", values } }, "*");
        }

        function restoreInputValues() {
          parent.postMessage({ pluginMessage: { type: "get-input-values" } }, "*");
        }

        function applyInputValues(values) {
          if (!values) return;
          
          const spacingScaleInput = document.getElementById("spacing-scale");
          const spacingThresholdInput = document.getElementById("spacing-threshold");
          const colorScaleInput = document.getElementById("color-scale");
          const fontSizeScaleInput = document.getElementById("font-size-scale");
          const fontSizeThresholdInput = document.getElementById("font-size-threshold");
          const lineHeightScaleInput = document.getElementById("line-height-scale");
          const lineHeightThresholdInput = document.getElementById("line-height-threshold");
          const lineHeightBaselineThresholdInput = document.getElementById("line-height-baseline-threshold");

          if (spacingScaleInput && values.spacingScale !== undefined) spacingScaleInput.value = values.spacingScale;
          if (spacingThresholdInput && values.spacingThreshold !== undefined) spacingThresholdInput.value = values.spacingThreshold;
          
          // Restore color name map before rendering color preview
          if (values.colorNameMap && typeof values.colorNameMap === "object") {
            colorNameMap = values.colorNameMap;
          } else {
            colorNameMap = {};
          }
          
          if (colorScaleInput && values.colorScale !== undefined) {
            colorScaleInput.value = values.colorScale;
            // Render color preview after loading saved colors and name map
            if (typeof renderColorPreview === "function") renderColorPreview();
          }
          if (fontSizeScaleInput && values.fontSizeScale !== undefined) fontSizeScaleInput.value = values.fontSizeScale;
          if (fontSizeThresholdInput && values.fontSizeThreshold !== undefined) fontSizeThresholdInput.value = values.fontSizeThreshold;
          if (lineHeightScaleInput && values.lineHeightScale !== undefined) lineHeightScaleInput.value = values.lineHeightScale;
          if (lineHeightThresholdInput && values.lineHeightThreshold !== undefined) lineHeightThresholdInput.value = values.lineHeightThreshold;
          if (lineHeightBaselineThresholdInput && values.lineHeightBaselineThreshold !== undefined) lineHeightBaselineThresholdInput.value = values.lineHeightBaselineThreshold;
          
          // Restore Typography Styles
          if (values.typographyStyles && Array.isArray(values.typographyStyles)) {
            typographyStyles = values.typographyStyles;
            nextTypoStyleId = Math.max(...typographyStyles.map(s => s.id || 0), 0) + 1;
            renderTypographyTable();
          }
          
          // Restore Typography Rules
          if (values.typographyRules) {
            const rules = values.typographyRules;
            if (document.getElementById("rule-typo-style")) document.getElementById("rule-typo-style").checked = rules.checkStyle !== false;
            if (document.getElementById("rule-font-family")) document.getElementById("rule-font-family").checked = rules.checkFontFamily !== false;
            if (document.getElementById("rule-font-size")) document.getElementById("rule-font-size").checked = rules.checkFontSize !== false;
            if (document.getElementById("rule-font-weight")) document.getElementById("rule-font-weight").checked = rules.checkFontWeight !== false;
            if (document.getElementById("rule-line-height")) document.getElementById("rule-line-height").checked = rules.checkLineHeight !== false;
            if (document.getElementById("rule-letter-spacing")) document.getElementById("rule-letter-spacing").checked = rules.checkLetterSpacing === true;
            if (document.getElementById("rule-word-spacing")) document.getElementById("rule-word-spacing").checked = rules.checkWordSpacing === true;
            
            // Re-render table after restoring checkbox states
            renderTypographyTable();
          }
        }

        function applySavedReport(saved) {
          if (!saved) {
            console.log("No last report to apply");
            return;
          }

          if (saved.scanMode) {
            const scopeRadio = document.querySelector(`input[name="scope"][value="${saved.scanMode}"]`);
            if (scopeRadio) {
              scopeRadio.checked = true;
            }
          }

          currentReportData.scanMode = saved.scanMode || currentReportData.scanMode;
          currentReportData.context = saved.context || currentReportData.context;

          // Restore issues if available
          if (saved.issues && Array.isArray(saved.issues)) {
            console.log("Applying saved issues report");
            renderResults(saved.issues, true, { skipSave: true, restoreTimestamp: saved.issuesTimestamp });
          }
          
          // Restore tokens if available
          if (saved.tokens) {
            console.log("Applying saved tokens report");
            renderTokens(saved.tokens, true, { skipSave: true, restoreTimestamp: saved.tokensTimestamp });
          }
          
          // Switch to the last active tab
          if (saved.lastActiveTab) {
            switchToTab(saved.lastActiveTab);
          } else if (saved.issues) {
            switchToTab("issues");
          } else if (saved.tokens) {
            switchToTab("tokens");
          }
        }

        // Filter state
        let currentFilter = "all";
        let currentSearch = "";
        let currentColorTypeFilter = "all";
        let isViewingTokens = false;

  console.log("All elements found, setting up event listeners");

  // Tab switching
  reportTabs.forEach(tab => {
    tab.addEventListener("click", () => {
      const tabName = tab.dataset.tab;
      
      // Update tabs
      reportTabs.forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      
      // Update content
      reportContents.forEach(c => c.classList.remove("active"));
      document.getElementById(`results-${tabName}`).classList.add("active");
      
      activeTab = tabName;
      
      // Save last active tab when user manually switches
      if (currentReportData.issues || currentReportData.tokens) {
        saveLastReport({
          issues: currentReportData.issues,
          issuesTimestamp: currentReportData.timestamp,
          tokens: currentReportData.tokens,
          tokensTimestamp: currentReportData.tokensTimestamp,
          lastActiveTab: tabName,
          scanMode: currentReportData.scanMode || null,
          context: currentReportData.context || null
        });
      }
    });
  });

  function clearResults(tabName = null) {
    const target = tabName ? document.getElementById(`results-${tabName}`) : resultsIssues;
    if (target) {
      target.innerHTML = "";
    }
  }
  
  function switchToTab(tabName) {
    reportTabs.forEach(tab => {
      if (tab.dataset.tab === tabName) {
        tab.classList.add("active");
      } else {
        tab.classList.remove("active");
      }
    });
    
    reportContents.forEach(content => {
      if (content.id === `results-${tabName}`) {
        content.classList.add("active");
      } else {
        content.classList.remove("active");
      }
    });
    
    activeTab = tabName;
  }

        function getSeverityIcon(severity) {
          if (severity === "error") return "‚ùå";
          if (severity === "warn") return "‚ö†Ô∏è";
          return "‚ÑπÔ∏è";
        }

        function getTypeIcon(type) {
          const icons = {
            naming: "üè∑Ô∏è",
            autolayout: "üìê",
            spacing: "üìè",
            color: "üé®",
            typography: "‚úçÔ∏è",
            "typography-style": "üé®",
            "typography-check": "üìù",
            "typography-pass": "‚úÖ",
            "typography-info": "‚úÖ",
            "line-height": "üìù",
            position: "üìç",
            duplicate: "üîÑ",
            group: "üì¶",
            component: "üß©",
            "empty-frame": "üì≠",
            "nested-group": "üìö",
            contrast: "üåà",
            "text-size-mobile": "üì±"
          };
          return icons[type] || "üîç";
        }

        function getTypeDisplayName(type) {
          const displayNames = {
            naming: "Naming Layer",
            autolayout: "Auto Layout",
            spacing: "Spacing",
            color: "Color",
            typography: "Font Size",
            "typography-style": "Text Style (variable)",
            "typography-check": "Typography Style Match",
            "typography-pass": "Typography ‚úì Matched",
            "line-height": "Line Height",
            position: "Position Layer",
            duplicate: "Duplicate Layer",
            group: "Group Layer",
            component: "Component Reusable",
            "empty-frame": "Empty Frame Layer",
            "nested-group": "Nested Group Layer",
            contrast: "Contrast (ADA AA)",
            "text-size-mobile": "Text Size (ADA)"
          };
          return displayNames[type] || type.replace(/-/g, " ");
        }

        function addIssueEl(issue) {
    const el = document.createElement("div");
          el.className = `issue ${issue.severity}`;
    
    // Build detailed info for typography issues
    let detailsHtml = "";
    if (issue.type === "typography-check" && issue.nodeProps) {
      detailsHtml = '<div class="typography-details" style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; font-size: 11px;">';
      
      // Current properties
      detailsHtml += '<div style="margin-bottom: 6px;"><strong>Current Properties:</strong></div>';
      detailsHtml += '<div style="padding-left: 12px; line-height: 1.6;">';
      if (issue.nodeProps.fontFamily) detailsHtml += `‚Ä¢ Font Family: <code>${escapeHtml(issue.nodeProps.fontFamily)}</code><br>`;
      if (issue.nodeProps.fontSize !== null && issue.nodeProps.fontSize !== undefined) detailsHtml += `‚Ä¢ Font Size: <code>${issue.nodeProps.fontSize}px</code><br>`;
      if (issue.nodeProps.fontWeight) detailsHtml += `‚Ä¢ Font Weight: <code>${escapeHtml(issue.nodeProps.fontWeight)}</code><br>`;
      if (issue.nodeProps.lineHeight) detailsHtml += `‚Ä¢ Line Height: <code>${escapeHtml(issue.nodeProps.lineHeight)}</code><br>`;
      if (issue.nodeProps.letterSpacing !== null && issue.nodeProps.letterSpacing !== undefined) detailsHtml += `‚Ä¢ Letter Spacing: <code>${escapeHtml(issue.nodeProps.letterSpacing)}</code><br>`;
      detailsHtml += '</div>';
      
      // Best match suggestion (for errors) or show matched style (for pass with severity info)
      if (issue.bestMatch && issue.severity === "error") {
        detailsHtml += `<div style="margin-top: 8px; margin-bottom: 4px;"><strong>Closest Match: "${escapeHtml(issue.bestMatch.name)}" (${issue.bestMatch.percentage}%)</strong></div>`;
        detailsHtml += '<div style="padding-left: 12px; line-height: 1.6;">';
        issue.bestMatch.differences.forEach(diff => {
          const icon = diff.matches ? '‚úì' : '‚úó';
          const color = diff.matches ? 'green' : 'red';
          detailsHtml += `<span style="color: ${color}">${icon} ${diff.property}: <code>${escapeHtml(diff.current)}</code> ‚Üí <code>${escapeHtml(diff.expected)}</code></span><br>`;
        });
        detailsHtml += '</div>';
      } else if (issue.severity === "info" && issue.styleName) {
        // Show matched style for info/pass cases
        detailsHtml += `<div style="margin-top: 8px; color: green;"><strong>‚úì All properties match style "${escapeHtml(issue.styleName)}"</strong></div>`;
      }
      
      detailsHtml += '</div>';
    }
    
    el.setAttribute("data-issue-id", issue.id);
    el.innerHTML = `
      <div class="issue-header">
              <div>
                <span class="issue-type">${getTypeIcon(issue.type)} ${getTypeDisplayName(issue.type)}</span>
      <div class="issue-body">${escapeHtml(issue.message)}</div>
                ${issue.nodeName ? `<div class="issue-node">Node: ${escapeHtml(issue.nodeName)}</div>` : ""}
                ${detailsHtml}
              </div>
              <div class="issue-actions">
                <button class="btn-select" data-id="${issue.id}">Select</button>
                ${(issue.bestMatch && issue.type === "typography-check") ? `<button class="btn-fix" data-id="${issue.id}">Fix now</button>` : ""}
              </div>
      </div>
    `;
    const btn = el.querySelector("button.btn-select");
    if (btn) {
      btn.onclick = () => {
        parent.postMessage({ pluginMessage: { type: "select-node", id: issue.id } }, "*");
      };
    }
    
    const btnFix = el.querySelector("button.btn-fix");
    if (btnFix) {
      btnFix.onclick = () => {
        handleFixIssue(issue);
      };
    }
    
    return el;
  }

  function escapeHtml(s) {
    if (s === null || s === undefined) return "";
    // Convert to string if not already
    const str = String(s);
    return str.replace(/[&<>"']/g, function (m) {
      return ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m];
    });
  }

  // Show fix message under issue item
  function showFixMessage(issueId, message, isSuccess) {
    const issueEl = document.querySelector(`.issue[data-issue-id="${issueId}"]`);
    if (!issueEl) {
      // Try to find by button data-id
      const btn = document.querySelector(`button.btn-fix[data-id="${issueId}"]`);
      if (btn) {
        issueEl = btn.closest(".issue");
      }
    }
    
    if (!issueEl) return;
    
    // Remove existing message if any
    const existingMsg = issueEl.querySelector(".fix-message");
    if (existingMsg) existingMsg.remove();
    
    // Create message element
    const msgEl = document.createElement("div");
    msgEl.className = "fix-message";
    msgEl.style.cssText = `
      margin-top: 8px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      background: ${isSuccess ? "#d4edda" : "#f8d7da"};
      color: ${isSuccess ? "#155724" : "#721c24"};
      border: 1px solid ${isSuccess ? "#c3e6cb" : "#f5c6cb"};
      animation: slideIn 0.3s ease-out;
    `;
    msgEl.textContent = message;
    
    // Insert after issue-header
    const issueHeader = issueEl.querySelector(".issue-header");
    if (issueHeader) {
      issueHeader.parentNode.insertBefore(msgEl, issueHeader.nextSibling);
    } else {
      issueEl.appendChild(msgEl);
    }
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      msgEl.style.animation = "slideOut 0.3s ease-out";
      setTimeout(() => {
        if (msgEl.parentNode) {
          msgEl.remove();
        }
      }, 300);
    }, 5000);
  }

  // Show typography fix confirmation modal
  function showTypographyFixModal(issue) {
    if (!issue || !issue.bestMatch) {
      console.error("showTypographyFixModal: missing issue or bestMatch");
      return;
    }
    
    const currentNode = issue.nodeProps || {};
    const bestMatch = issue.bestMatch;
    
    // Get current values
    const currentFamily = currentNode.fontFamily || "";
    const currentSize = currentNode.fontSize !== null && currentNode.fontSize !== undefined ? currentNode.fontSize : "";
    const currentWeight = currentNode.fontWeight || "";
    const currentLineHeight = currentNode.lineHeight || "";
    const currentLetterSpacing = currentNode.letterSpacing !== null && currentNode.letterSpacing !== undefined ? currentNode.letterSpacing : "";
    
    // Get suggested values from bestMatch differences
    let suggestedFamily = currentFamily;
    let suggestedSize = currentSize;
    let suggestedWeight = currentWeight;
    let suggestedLineHeight = currentLineHeight;
    let suggestedLetterSpacing = currentLetterSpacing;
    
    if (bestMatch.differences) {
      bestMatch.differences.forEach(diff => {
        if (diff.property === "Font Family" && diff.expected) {
          suggestedFamily = diff.expected;
        } else if (diff.property === "Font Size" && diff.expected) {
          suggestedSize = diff.expected.replace("px", "");
        } else if (diff.property === "Font Weight" && diff.expected) {
          suggestedWeight = diff.expected;
        } else if (diff.property === "Line Height" && diff.expected) {
          suggestedLineHeight = diff.expected;
        } else if (diff.property === "Letter Spacing" && diff.expected) {
          suggestedLetterSpacing = diff.expected;
        }
      });
    }
    
    // Create modal overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.id = "typography-fix-modal-overlay";
    
    // Create modal dialog
    const dialog = document.createElement("div");
    dialog.className = "modal-dialog";
    dialog.style.maxWidth = "500px";
    
    dialog.innerHTML = `
      <div class="modal-header">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title">Fix Typography Style</h2>
        <p class="modal-subtitle">Node: ${escapeHtml(issue.nodeName || "Unnamed")} ‚Üí Suggested: ${escapeHtml(bestMatch.name)}</p>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <div style="font-size: 13px; color: #666; margin-bottom: 12px;">
            Edit values below and click Apply to fix:
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">Font Family</label>
            <input type="text" class="modal-input" id="fix-font-family" value="${escapeHtml(suggestedFamily)}" style="width: 100%;" />
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">Font Size (px)</label>
            <input type="number" class="modal-input" id="fix-font-size" value="${escapeHtml(suggestedSize)}" style="width: 100%;" />
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">Font Weight</label>
            <select class="modal-input" id="fix-font-weight" style="width: 100%;">
              <option value="Regular" ${suggestedWeight === "Regular" ? "selected" : ""}>Regular</option>
              <option value="Medium" ${suggestedWeight === "Medium" ? "selected" : ""}>Medium</option>
              <option value="SemiBold" ${suggestedWeight === "SemiBold" || suggestedWeight === "Semi Bold" ? "selected" : ""}>SemiBold</option>
              <option value="Bold" ${suggestedWeight === "Bold" ? "selected" : ""}>Bold</option>
            </select>
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">Line Height (% or px or auto)</label>
            <input type="text" class="modal-input" id="fix-line-height" value="${escapeHtml(suggestedLineHeight)}" style="width: 100%;" placeholder="e.g. 120%, 24px, auto" />
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;">Letter Spacing (px or %)</label>
            <input type="text" class="modal-input" id="fix-letter-spacing" value="${escapeHtml(suggestedLetterSpacing)}" style="width: 100%;" placeholder="e.g. 0, 0.5px, 1%" />
          </div>
          
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #eee;">
            <button class="modal-btn modal-btn-cancel" id="choose-typo-style-btn" style="width: 100%; margin-bottom: 8px; background: #0071e3; border-color: #0071e3; color: white;">
              Choose Typography Style
            </button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="typography-fix-modal-cancel-btn">Cancel</button>
        <button class="modal-btn modal-btn-create" id="typography-fix-modal-apply-btn" style="background: #28a745; border-color: #28a745;">Apply</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Get elements
    const fontFamilyInput = dialog.querySelector("#fix-font-family");
    const fontSizeInput = dialog.querySelector("#fix-font-size");
    const fontWeightSelect = dialog.querySelector("#fix-font-weight");
    const lineHeightInput = dialog.querySelector("#fix-line-height");
    const letterSpacingInput = dialog.querySelector("#fix-letter-spacing");
    const chooseStyleBtn = dialog.querySelector("#choose-typo-style-btn");
    const cancelBtn = dialog.querySelector("#typography-fix-modal-cancel-btn");
    const applyBtn = dialog.querySelector("#typography-fix-modal-apply-btn");
    const closeBtn = dialog.querySelector(".modal-close");
    
    // Focus first input
    setTimeout(() => {
      fontFamilyInput.focus();
    }, 100);
    
    // Close function
    const closeModal = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Cancel button
    cancelBtn.onclick = closeModal;
    closeBtn.onclick = closeModal;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeModal();
      }
    };
    
    // Choose Typography Style button
    chooseStyleBtn.onclick = () => {
      // Show dropdown for typography styles
      showTypographyStylePicker((selectedStyle) => {
        // Fill inputs with selected style values
        if (selectedStyle) {
          fontFamilyInput.value = selectedStyle.fontFamily || "";
          fontSizeInput.value = selectedStyle.fontSize || "";
          fontWeightSelect.value = selectedStyle.fontWeight || "Regular";
          lineHeightInput.value = selectedStyle.lineHeight || "";
          letterSpacingInput.value = selectedStyle.letterSpacing || "0";
        }
      });
    };
    
    // Apply button
    applyBtn.onclick = () => {
      // Collect values
      const fixData = {
        fontFamily: fontFamilyInput.value.trim(),
        fontSize: fontSizeInput.value.trim(),
        fontWeight: fontWeightSelect.value,
        lineHeight: lineHeightInput.value.trim(),
        letterSpacing: letterSpacingInput.value.trim()
      };
      
      // Validate
      if (!fixData.fontFamily) {
        fontFamilyInput.focus();
        fontFamilyInput.style.borderColor = "#ff3b30";
        setTimeout(() => {
          fontFamilyInput.style.borderColor = "#0071e3";
        }, 2000);
        return;
      }
      
      if (!fixData.fontSize || isNaN(parseFloat(fixData.fontSize))) {
        fontSizeInput.focus();
        fontSizeInput.style.borderColor = "#ff3b30";
        setTimeout(() => {
          fontSizeInput.style.borderColor = "#0071e3";
        }, 2000);
        return;
      }
      
      closeModal();
      
      // Show loading message
      showFixMessage(issue.id, "‚è≥ Fixing...", true);
      
      // Send fix request with custom values
      parent.postMessage({
        pluginMessage: {
          type: "fix-issue",
          issue: issue,
          fixData: fixData
        }
      }, "*");
    };
  }

  // Show typography style picker dropdown
  function showTypographyStylePicker(onSelect) {
    if (!typographyStyles || typographyStyles.length === 0) {
      alert("No typography styles available. Please add styles in Typography Settings.");
      return;
    }
    
    // Create dropdown overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.style.zIndex = "10001";
    
    const dropdown = document.createElement("div");
    dropdown.className = "modal-dialog";
    dropdown.style.maxWidth = "300px";
    dropdown.style.padding = "0";
    
    dropdown.innerHTML = `
      <div class="modal-header" style="padding: 16px;">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title" style="font-size: 14px;">Choose Typography Style</h2>
      </div>
      <div style="max-height: 300px; overflow-y: auto;">
        ${typographyStyles.map(style => {
          const name = escapeHtml(style.name || "");
          const fontFamily = escapeHtml(style.fontFamily || "");
          const fontSize = escapeHtml(style.fontSize || "");
          const fontWeight = escapeHtml(style.fontWeight || "");
          return `
          <div class="style-dropdown-item" data-style-id="${style.id}" style="padding: 12px 16px; cursor: pointer; font-size: 13px; border-bottom: 1px solid #f0f0f0;" onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='white'">
            <div style="font-weight: 600; color: #333;">${name}</div>
            <div style="font-size: 11px; color: #666; margin-top: 4px;">
              ${fontFamily} ${fontSize}px ${fontWeight}
            </div>
          </div>
        `;
        }).join('')}
      </div>
    `;
    
    overlay.appendChild(dropdown);
    document.body.appendChild(overlay);
    
    // Close function
    const closeDropdown = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Close button
    dropdown.querySelector(".modal-close").onclick = closeDropdown;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeDropdown();
      }
    };
    
    // Item clicks
    dropdown.querySelectorAll(".style-dropdown-item").forEach(item => {
      item.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const styleId = parseInt(item.getAttribute("data-style-id"));
        const style = typographyStyles.find(s => s.id === styleId);
        if (style && onSelect) {
          onSelect(style);
          closeDropdown();
        }
      };
    });
  }

  // Handle fix spacing issue
  function handleFixSpacingIssue(issue) {
    // Extract property name and current value from message
    const message = issue.message || "";
    // Match: "Padding paddingLeft (64px)" or "Padding paddingRight (32px)" etc.
    const match = message.match(/Padding\s+(\w+)\s+\((\d+)px\)/);
    if (!match) {
      alert("Cannot determine spacing property from issue message");
      return;
    }
    
    const propertyName = match[1]; // paddingLeft, paddingRight, paddingTop, paddingBottom
    const currentValue = parseInt(match[2]); // 64
    
    // Get spacing scale from input
    const spacingScaleInput = document.getElementById("spacing-scale");
    if (!spacingScaleInput || !spacingScaleInput.value.trim()) {
      alert("No spacing scale defined. Please add spacing values to the Spacing input.");
      return;
    }
    
    // Parse spacing values from input
    const spacingValues = spacingScaleInput.value.split(",")
      .map(v => parseInt(v.trim(), 10))
      .filter(v => !isNaN(v) && v >= 0)
      .sort((a, b) => a - b); // Sort ascending
    
    if (spacingValues.length === 0) {
      alert("No valid spacing values found in Spacing input.");
      return;
    }
    
    // Show spacing picker modal
    showSpacingPickerModal(issue, propertyName, currentValue, spacingValues);
  }

  // Show spacing picker modal
  function showSpacingPickerModal(issue, propertyName, currentValue, availableValues) {
    // Create modal overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.id = "spacing-picker-modal-overlay";
    
    // Create modal dialog
    const dialog = document.createElement("div");
    dialog.className = "modal-dialog";
    dialog.style.maxWidth = "400px";
    
    // Build spacing list HTML
    const spacingListHtml = availableValues.map(value => {
      return `
        <div class="spacing-picker-item" data-value="${value}" style="
          padding: 12px;
          margin-bottom: 8px;
          border: 2px solid ${currentValue === value ? '#0071e3' : '#ddd'};
          border-radius: 8px;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: space-between;
          background: white;
          transition: all 0.2s;
        " onmouseover="this.style.borderColor='#0071e3'; this.style.boxShadow='0 2px 8px rgba(0,113,227,0.2)'" onmouseout="this.style.borderColor='${currentValue === value ? '#0071e3' : '#ddd'}'; this.style.boxShadow='none'">
          <div style="display: flex; align-items: center; gap: 12px;">
            <div style="
              width: 40px;
              height: 40px;
              border-radius: 4px;
              background: #f0f0f0;
              border: 1px solid #ddd;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 12px;
              font-weight: 600;
              color: #666;
            ">${value}px</div>
            <div style="font-weight: 600; font-size: 14px; color: #333;">
              ${value}px
            </div>
          </div>
          ${currentValue === value ? '<div style="color: #0071e3; font-weight: 600;">Current</div>' : ''}
        </div>
      `;
    }).join('');
    
    // Format property name for display
    const propertyDisplayName = propertyName
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
    
    dialog.innerHTML = `
      <div class="modal-header">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title">Choose Spacing Value</h2>
        <p class="modal-subtitle">Node: ${escapeHtml(issue.nodeName || "Unnamed")} - ${escapeHtml(propertyDisplayName)}</p>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 12px; padding: 12px; background: #f5f5f5; border-radius: 6px;">
          <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Current Value:</div>
          <div style="font-size: 16px; font-weight: 600; color: #333;">${currentValue}px</div>
        </div>
        <div style="max-height: 300px; overflow-y: auto;">
          ${spacingListHtml}
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="spacing-picker-modal-cancel-btn">Cancel</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Get elements
    const cancelBtn = dialog.querySelector("#spacing-picker-modal-cancel-btn");
    const closeBtn = dialog.querySelector(".modal-close");
    const spacingItems = dialog.querySelectorAll(".spacing-picker-item");
    
    // Close function
    const closeModal = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Cancel button
    cancelBtn.onclick = closeModal;
    closeBtn.onclick = closeModal;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeModal();
      }
    };
    
    // Spacing item clicks
    spacingItems.forEach(item => {
      item.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const selectedValue = parseInt(item.getAttribute("data-value"));
        closeModal();
        // Show confirm modal
        showSpacingFixConfirmModal(issue, propertyName, currentValue, selectedValue);
      };
    });
  }

  // Show spacing fix confirm modal
  function showSpacingFixConfirmModal(issue, propertyName, currentValue, selectedValue) {
    // Format property name for display
    const propertyDisplayName = propertyName
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
    
    // Create modal overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.id = "spacing-fix-confirm-modal-overlay";
    
    // Create modal dialog
    const dialog = document.createElement("div");
    dialog.className = "modal-dialog";
    dialog.style.maxWidth = "400px";
    
    dialog.innerHTML = `
      <div class="modal-header">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title">Confirm Spacing Change</h2>
        <p class="modal-subtitle">Node: ${escapeHtml(issue.nodeName || "Unnamed")}</p>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <div style="font-size: 13px; color: #666; margin-bottom: 12px;">Change ${escapeHtml(propertyDisplayName)} from:</div>
          <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #f5f5f5; border-radius: 6px; margin-bottom: 12px;">
            <div style="
              width: 60px;
              height: 60px;
              border-radius: 6px;
              background: #f0f0f0;
              border: 2px solid #ddd;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              font-weight: 600;
              color: #333;
            ">${currentValue}px</div>
            <div>
              <div style="font-weight: 600; font-size: 16px; color: #333;">${currentValue}px</div>
            </div>
          </div>
          <div style="font-size: 13px; color: #666; margin-bottom: 12px;">To:</div>
          <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #e3f2fd; border-radius: 6px;">
            <div style="
              width: 60px;
              height: 60px;
              border-radius: 6px;
              background: #e3f2fd;
              border: 2px solid #0071e3;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              font-weight: 600;
              color: #0071e3;
            ">${selectedValue}px</div>
            <div>
              <div style="font-weight: 600; font-size: 16px; color: #333;">${selectedValue}px</div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="spacing-fix-confirm-cancel-btn">Cancel</button>
        <button class="modal-btn modal-btn-create" id="spacing-fix-confirm-apply-btn" style="background: #28a745; border-color: #28a745;">Apply</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Get elements
    const cancelBtn = dialog.querySelector("#spacing-fix-confirm-cancel-btn");
    const applyBtn = dialog.querySelector("#spacing-fix-confirm-apply-btn");
    const closeBtn = dialog.querySelector(".modal-close");
    
    // Close function
    const closeModal = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Cancel button
    cancelBtn.onclick = closeModal;
    closeBtn.onclick = closeModal;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeModal();
      }
    };
    
    // Apply button
    applyBtn.onclick = () => {
      closeModal();
      
      // Show loading message
      showFixMessage(issue.id, "‚è≥ Fixing spacing...", true);
      
      // Send fix spacing request
      parent.postMessage({
        pluginMessage: {
          type: "fix-spacing-issue",
          issue: issue,
          propertyName: propertyName,
          value: selectedValue
        }
      }, "*");
    };
  }

  // Handle fix color issue
  function handleFixColorIssue(issue) {
    // Extract current color from message
    const message = issue.message || "";
    const colorMatch = message.match(/Color (#[0-9A-Fa-f]{6})/);
    const currentColor = colorMatch ? colorMatch[1].toUpperCase() : null;
    
    if (!currentColor) {
      alert("Cannot determine current color from issue message");
      return;
    }
    
    // Get color scale from input
    const colorScaleInput = document.getElementById("color-scale");
    if (!colorScaleInput || !colorScaleInput.value.trim()) {
      alert("No color scale defined. Please add colors to the Color input.");
      return;
    }
    
    // Parse colors from input
    const colors = colorScaleInput.value.split(",")
      .map(c => c.trim().toUpperCase())
      .filter(c => c && c.startsWith("#"));
    
    if (colors.length === 0) {
      alert("No valid colors found in Color input.");
      return;
    }
    
    // Show color picker modal
    showColorPickerModal(issue, currentColor, colors);
  }

  // Show color picker modal
  function showColorPickerModal(issue, currentColor, availableColors) {
    // Create modal overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.id = "color-picker-modal-overlay";
    
    // Create modal dialog
    const dialog = document.createElement("div");
    dialog.className = "modal-dialog";
    dialog.style.maxWidth = "400px";
    
    // Build color list HTML
    const colorListHtml = availableColors.map(color => {
      const colorName = colorNameMap[color] || "";
      const textColor = getContrastTextColor(color);
      return `
        <div class="color-picker-item" data-color="${escapeHtml(color)}" style="
          padding: 12px;
          margin-bottom: 8px;
          border: 2px solid ${currentColor === color ? '#0071e3' : '#ddd'};
          border-radius: 8px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 12px;
          background: white;
          transition: all 0.2s;
        " onmouseover="this.style.borderColor='#0071e3'; this.style.boxShadow='0 2px 8px rgba(0,113,227,0.2)'" onmouseout="this.style.borderColor='${currentColor === color ? '#0071e3' : '#ddd'}'; this.style.boxShadow='none'">
          <div style="
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: ${escapeHtml(color)};
            border: 2px solid #ddd;
            flex-shrink: 0;
          "></div>
          <div style="flex: 1;">
            <div style="font-weight: 600; font-size: 14px; color: #333; margin-bottom: 4px;">
              ${escapeHtml(colorName || color)}
            </div>
            <div style="font-size: 12px; color: #666; font-family: 'SF Mono', Monaco, monospace;">
              ${escapeHtml(color)}
            </div>
          </div>
          ${currentColor === color ? '<div style="color: #0071e3; font-weight: 600;">Current</div>' : ''}
        </div>
      `;
    }).join('');
    
    dialog.innerHTML = `
      <div class="modal-header">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title">Choose Color</h2>
        <p class="modal-subtitle">Node: ${escapeHtml(issue.nodeName || "Unnamed")}</p>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 12px; padding: 12px; background: #f5f5f5; border-radius: 6px;">
          <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Current Color:</div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: 32px; height: 32px; border-radius: 4px; background: ${escapeHtml(currentColor)}; border: 1px solid #ddd;"></div>
            <div style="font-family: 'SF Mono', Monaco, monospace; font-size: 13px; font-weight: 600;">${escapeHtml(currentColor)}</div>
          </div>
        </div>
        <div style="max-height: 300px; overflow-y: auto;">
          ${colorListHtml}
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="color-picker-modal-cancel-btn">Cancel</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Get elements
    const cancelBtn = dialog.querySelector("#color-picker-modal-cancel-btn");
    const closeBtn = dialog.querySelector(".modal-close");
    const colorItems = dialog.querySelectorAll(".color-picker-item");
    
    // Close function
    const closeModal = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Cancel button
    cancelBtn.onclick = closeModal;
    closeBtn.onclick = closeModal;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeModal();
      }
    };
    
    // Color item clicks
    colorItems.forEach(item => {
      item.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const selectedColor = item.getAttribute("data-color");
        closeModal();
        // Show confirm modal
        showColorFixConfirmModal(issue, currentColor, selectedColor);
      };
    });
  }

  // Show color fix confirm modal
  function showColorFixConfirmModal(issue, currentColor, selectedColor) {
    const colorName = colorNameMap[selectedColor] || selectedColor;
    
    // Create modal overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.id = "color-fix-confirm-modal-overlay";
    
    // Create modal dialog
    const dialog = document.createElement("div");
    dialog.className = "modal-dialog";
    dialog.style.maxWidth = "400px";
    
    dialog.innerHTML = `
      <div class="modal-header">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title">Confirm Color Change</h2>
        <p class="modal-subtitle">Node: ${escapeHtml(issue.nodeName || "Unnamed")}</p>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <div style="font-size: 13px; color: #666; margin-bottom: 12px;">Change color from:</div>
          <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #f5f5f5; border-radius: 6px; margin-bottom: 12px;">
            <div style="width: 48px; height: 48px; border-radius: 6px; background: ${escapeHtml(currentColor)}; border: 2px solid #ddd;"></div>
            <div>
              <div style="font-weight: 600; font-size: 14px; color: #333;">${escapeHtml(currentColor)}</div>
            </div>
          </div>
          <div style="font-size: 13px; color: #666; margin-bottom: 12px;">To:</div>
          <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #e3f2fd; border-radius: 6px;">
            <div style="width: 48px; height: 48px; border-radius: 6px; background: ${escapeHtml(selectedColor)}; border: 2px solid #0071e3;"></div>
            <div>
              <div style="font-weight: 600; font-size: 14px; color: #333;">${escapeHtml(colorName)}</div>
              <div style="font-size: 12px; color: #666; font-family: 'SF Mono', Monaco, monospace;">${escapeHtml(selectedColor)}</div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="color-fix-confirm-cancel-btn">Cancel</button>
        <button class="modal-btn modal-btn-create" id="color-fix-confirm-apply-btn" style="background: #28a745; border-color: #28a745;">Apply</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Get elements
    const cancelBtn = dialog.querySelector("#color-fix-confirm-cancel-btn");
    const applyBtn = dialog.querySelector("#color-fix-confirm-apply-btn");
    const closeBtn = dialog.querySelector(".modal-close");
    
    // Close function
    const closeModal = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Cancel button
    cancelBtn.onclick = closeModal;
    closeBtn.onclick = closeModal;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeModal();
      }
    };
    
    // Apply button
    applyBtn.onclick = () => {
      closeModal();
      
      // Show loading message
      showFixMessage(issue.id, "‚è≥ Fixing color...", true);
      
      // Send fix color request
      parent.postMessage({
        pluginMessage: {
          type: "fix-color-issue",
          issue: issue,
          color: selectedColor
        }
      }, "*");
    };
  }

  // Handle fix single issue
  function handleFixIssue(issue) {
    // For typography-check issues, show confirmation modal
    if (issue.type === "typography-check" && issue.bestMatch) {
      showTypographyFixModal(issue);
      return;
    }
    
    // Show loading message immediately
    showFixMessage(issue.id, "‚è≥ Fixing...", true);
    
    if (!issue.bestMatch && issue.type !== "typography-check") {
      // Show popup for manual fix
      const userInput = prompt(`Cannot auto-fix this issue.\n\nIssue: ${issue.message}\n\nPlease provide fix instructions or press Cancel.`);
      if (userInput) {
        // Send manual fix request
        parent.postMessage({ 
          pluginMessage: { 
            type: "fix-issue", 
            issue: issue,
            manualFix: userInput
          } 
        }, "*");
      } else {
        // Remove loading message if cancelled
        const issueEl = document.querySelector(`.issue[data-issue-id="${issue.id}"]`) || 
                       document.querySelector(`button.btn-fix[data-id="${issue.id}"]`)?.closest(".issue");
        if (issueEl) {
          const msg = issueEl.querySelector(".fix-message");
          if (msg) msg.remove();
        }
      }
      return;
    }

    // Auto-fix with bestMatch
    parent.postMessage({ 
      pluginMessage: { 
        type: "fix-issue", 
        issue: issue
      } 
    }, "*");
  }

  // Show create style modal
  function showCreateStyleModal(issue, onConfirm) {
    // Create modal overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.id = "create-style-modal-overlay";
    
    // Create modal dialog
    const dialog = document.createElement("div");
    dialog.className = "modal-dialog";
    
    // Get subtitle text
    let subtitleText = issue.nodeName || "Unnamed";
    if (issue.message && issue.message.includes("(") && issue.message.includes("nodes")) {
      // Extract node count if available
      const match = issue.message.match(/\((\d+) nodes\)/);
      if (match) {
        subtitleText = `${subtitleText} (${match[1]} nodes)`;
      }
    }
    
    dialog.innerHTML = `
      <div class="modal-header">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title">Create Style</h2>
        <p class="modal-subtitle">${escapeHtml(subtitleText)}</p>
      </div>
      <div class="modal-body">
        <input 
          type="text" 
          class="modal-input" 
          id="style-name-input" 
          placeholder="Style Name" 
          value="${escapeHtml(issue.nodeName || "New Style")}"
          autofocus
        />
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="modal-cancel-btn">Cancel</button>
        <button class="modal-btn modal-btn-create" id="modal-create-btn">Create</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Get elements
    const input = dialog.querySelector("#style-name-input");
    const cancelBtn = dialog.querySelector("#modal-cancel-btn");
    const createBtn = dialog.querySelector("#modal-create-btn");
    const closeBtn = dialog.querySelector(".modal-close");
    
    // Focus input
    setTimeout(() => {
      input.focus();
      input.select();
    }, 100);
    
    // Handle Enter key
    input.onkeydown = (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        createBtn.click();
      } else if (e.key === "Escape") {
        e.preventDefault();
        cancelBtn.click();
      }
    };
    
    // Close function
    const closeModal = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Cancel button
    cancelBtn.onclick = closeModal;
    closeBtn.onclick = closeModal;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeModal();
      }
    };
    
    // Create button
    createBtn.onclick = () => {
      const styleName = input.value.trim();
      if (!styleName) {
        input.focus();
        input.style.borderColor = "#ff3b30";
        setTimeout(() => {
          input.style.borderColor = "#0071e3";
        }, 2000);
        return;
      }
      
      closeModal();
      if (onConfirm) {
        onConfirm(styleName);
      }
    };
  }

  // Show suggest apply modal
  function showSuggestApplyModal(issue, styleName) {
    if (!issue || !styleName) {
      console.error("showSuggestApplyModal: missing issue or styleName");
      return;
    }
    
    // Find the style
    const style = typographyStyles.find(s => s.name === styleName);
    if (!style) {
      alert(`Style "${styleName}" not found`);
      return;
    }
    
    // Get current node properties
    const currentNode = issue.nodeProps || {};
    const currentFamily = currentNode.fontFamily || "Unknown";
    const currentSize = currentNode.fontSize !== null && currentNode.fontSize !== undefined ? `${currentNode.fontSize}px` : "Unknown";
    const currentWeight = currentNode.fontWeight || "Unknown";
    const currentLineHeight = currentNode.lineHeight || "Unknown";
    const currentLetterSpacing = currentNode.letterSpacing !== null && currentNode.letterSpacing !== undefined ? currentNode.letterSpacing : "Unknown";
    
    // Get suggested style properties
    const suggestedFamily = style.fontFamily || "Unknown";
    const suggestedSize = style.fontSize ? `${style.fontSize}px` : "Unknown";
    const suggestedWeight = style.fontWeight || "Unknown";
    const suggestedLineHeight = style.lineHeight || "Unknown";
    const suggestedLetterSpacing = style.letterSpacing !== null && style.letterSpacing !== undefined ? style.letterSpacing : "Unknown";
    
    // Create modal overlay
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.id = "suggest-apply-modal-overlay";
    
    // Create modal dialog
    const dialog = document.createElement("div");
    dialog.className = "modal-dialog";
    dialog.style.maxWidth = "500px";
    
    // Build comparison HTML
    const comparisonHtml = `
      <div style="margin-top: 16px; font-size: 13px;">
        <div style="margin-bottom: 12px; font-weight: 600; color: #333;">Comparison:</div>
        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
          <thead>
            <tr style="border-bottom: 1px solid #ddd;">
              <th style="text-align: left; padding: 8px; font-weight: 600; color: #666;">Property</th>
              <th style="text-align: left; padding: 8px; font-weight: 600; color: #666;">Current</th>
              <th style="text-align: left; padding: 8px; font-weight: 600; color: #28a745;">Suggested</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid #f0f0f0;">
              <td style="padding: 8px; color: #666;">Font Family</td>
              <td style="padding: 8px;"><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">${escapeHtml(currentFamily)}</code></td>
              <td style="padding: 8px;"><code style="background: #d4edda; padding: 2px 6px; border-radius: 3px; color: #155724;">${escapeHtml(suggestedFamily)}</code></td>
            </tr>
            <tr style="border-bottom: 1px solid #f0f0f0;">
              <td style="padding: 8px; color: #666;">Font Size</td>
              <td style="padding: 8px;"><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">${escapeHtml(currentSize)}</code></td>
              <td style="padding: 8px;"><code style="background: #d4edda; padding: 2px 6px; border-radius: 3px; color: #155724;">${escapeHtml(suggestedSize)}</code></td>
            </tr>
            <tr style="border-bottom: 1px solid #f0f0f0;">
              <td style="padding: 8px; color: #666;">Font Weight</td>
              <td style="padding: 8px;"><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">${escapeHtml(currentWeight)}</code></td>
              <td style="padding: 8px;"><code style="background: #d4edda; padding: 2px 6px; border-radius: 3px; color: #155724;">${escapeHtml(suggestedWeight)}</code></td>
            </tr>
            <tr style="border-bottom: 1px solid #f0f0f0;">
              <td style="padding: 8px; color: #666;">Line Height</td>
              <td style="padding: 8px;"><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">${escapeHtml(currentLineHeight)}</code></td>
              <td style="padding: 8px;"><code style="background: #d4edda; padding: 2px 6px; border-radius: 3px; color: #155724;">${escapeHtml(suggestedLineHeight)}</code></td>
            </tr>
            <tr>
              <td style="padding: 8px; color: #666;">Letter Spacing</td>
              <td style="padding: 8px;"><code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">${escapeHtml(currentLetterSpacing)}</code></td>
              <td style="padding: 8px;"><code style="background: #d4edda; padding: 2px 6px; border-radius: 3px; color: #155724;">${escapeHtml(suggestedLetterSpacing)}</code></td>
            </tr>
          </tbody>
        </table>
      </div>
    `;
    
    dialog.innerHTML = `
      <div class="modal-header">
        <button class="modal-close" aria-label="Close">√ó</button>
        <h2 class="modal-title">Apply Suggested Style</h2>
        <p class="modal-subtitle">Node: ${escapeHtml(issue.nodeName || "Unnamed")}</p>
      </div>
      <div class="modal-body">
        <div style="margin-bottom: 16px;">
          <div style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 8px;">
            Suggested Style: <span style="color: #28a745;">${escapeHtml(styleName)}</span>
          </div>
          ${issue.bestMatch && issue.bestMatch.percentage ? `
            <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
              Match: <strong>${issue.bestMatch.percentage}%</strong>
            </div>
          ` : ''}
        </div>
        ${comparisonHtml}
      </div>
      <div class="modal-footer">
        <button class="modal-btn modal-btn-cancel" id="suggest-modal-cancel-btn">Cancel</button>
        <button class="modal-btn modal-btn-create" id="suggest-modal-apply-btn" style="background: #28a745; border-color: #28a745;">Apply Style</button>
      </div>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Get elements
    const cancelBtn = dialog.querySelector("#suggest-modal-cancel-btn");
    const applyBtn = dialog.querySelector("#suggest-modal-apply-btn");
    const closeBtn = dialog.querySelector(".modal-close");
    
    // Close function
    const closeModal = () => {
      overlay.style.animation = "fadeIn 0.2s ease-out reverse";
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.remove();
        }
      }, 200);
    };
    
    // Cancel button
    cancelBtn.onclick = closeModal;
    closeBtn.onclick = closeModal;
    
    // Click overlay to close
    overlay.onclick = (e) => {
      if (e.target === overlay) {
        closeModal();
      }
    };
    
    // Apply button
    applyBtn.onclick = () => {
      closeModal();
      // Show loading message
      showFixMessage(issue.id, "‚è≥ Applying style...", true);
      
      // Send apply style request
      parent.postMessage({
        pluginMessage: {
          type: "apply-typography-style",
          issue: issue,
          style: style
        }
      }, "*");
    };
  }

  // Handle apply Figma text style to node
  function handleApplyFigmaTextStyle(issue, style) {
    if (!issue || !style) {
      console.error("handleApplyFigmaTextStyle: missing issue or style");
      return;
    }
    
    // Show loading message
    showFixMessage(issue.id, "‚è≥ Applying style...", true);
    
    // Send apply Figma text style request
    parent.postMessage({
      pluginMessage: {
        type: "apply-figma-text-style",
        issue: issue,
        styleId: style.id,
        styleName: style.name
      }
    }, "*");
  }

  // Handle apply typography style to node (from typography table)
  function handleApplyTypographyStyle(issue, styleName) {
    if (!issue || !styleName) {
      console.error("handleApplyTypographyStyle: missing issue or styleName");
      return;
    }
    
    // Show suggest modal first
    showSuggestApplyModal(issue, styleName);
  }

  // Handle create text style for typography-style issue
  function handleCreateTextStyle(issue) {
    console.log("handleCreateTextStyle called", issue);
    
    if (!issue) {
      console.error("handleCreateTextStyle: issue is null/undefined");
      return;
    }
    
    // Show custom modal
    showCreateStyleModal(issue, (styleName) => {
      console.log("handleCreateTextStyle: sending message", { type: "create-text-style", issueId: issue.id, styleName: styleName });
      
      // Show loading message
      showFixMessage(issue.id, "‚è≥ Creating style...", true);
      
      // Send create style request
      parent.postMessage({
        pluginMessage: {
          type: "create-text-style",
          issue: issue,
          styleName: styleName
        }
      }, "*");
    });
  }

  // Handle fix all issues in a group
  function handleFixAllIssues(type, issues) {
    // Handle typography-style: create styles for all
    if (type === "typography-style") {
      // Create a fake issue object for the modal
      const fakeIssue = {
        nodeName: `${issues.length} text node(s)`,
        message: `Found ${issues.length} text node(s) without text style`
      };
      
      showCreateStyleModal(fakeIssue, (styleName) => {
        // Show loading for all issues
        issues.forEach(issue => {
          showFixMessage(issue.id, "‚è≥ Creating style...", true);
        });
        
        // Send create style for all request
        parent.postMessage({
          pluginMessage: {
            type: "create-text-style-all",
            issues: issues,
            styleName: styleName
          }
        }, "*");
      });
      return;
    }
    
    // Handle typography-check: fix with bestMatch
    const fixableIssues = issues.filter(i => i.bestMatch && i.type === "typography-check");
    const nonFixableIssues = issues.filter(i => !i.bestMatch || i.type !== "typography-check");

    if (fixableIssues.length === 0) {
      alert(`No auto-fixable issues found in ${getTypeDisplayName(type)}.\n\nAll ${issues.length} issues require manual intervention.`);
      return;
    }

    if (nonFixableIssues.length > 0) {
      const proceed = confirm(
        `Found ${fixableIssues.length} auto-fixable issues and ${nonFixableIssues.length} issues that require manual fix.\n\n` +
        `Do you want to auto-fix the ${fixableIssues.length} issues now?\n\n` +
        `The ${nonFixableIssues.length} issues will need to be fixed manually.`
      );
      if (!proceed) return;
    }

    // Send fix all request
    parent.postMessage({ 
      pluginMessage: { 
        type: "fix-all-issues", 
        issues: fixableIssues,
        issueType: type
      } 
    }, "*");
  }

  function getContrastTextColor(hexColor) {
    // Determine if text should be white or black based on background color
    try {
      const r = parseInt(hexColor.slice(1, 3), 16);
      const g = parseInt(hexColor.slice(3, 5), 16);
      const b = parseInt(hexColor.slice(5, 7), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 128 ? "#000000" : "#ffffff";
    } catch (e) {
      return "#000000";
    }
  }

        function filterAndSearchIssues(issues) {
          console.log("filterAndSearchIssues called", { 
            totalIssues: issues.length, 
            currentFilter, 
            currentSearch 
          });
          let filtered = issues;

          // Filter by severity
          if (currentFilter !== "all") {
            filtered = filtered.filter(issue => issue.severity === currentFilter);
            console.log("After severity filter:", filtered.length);
          }

          // Search
          if (currentSearch.trim()) {
            const searchLower = currentSearch.toLowerCase();
            filtered = filtered.filter(issue => {
              const message = (issue.message || "").toLowerCase();
              const nodeName = (issue.nodeName || "").toLowerCase();
              const type = (issue.type || "").toLowerCase();
              return message.includes(searchLower) || 
                     nodeName.includes(searchLower) || 
                     type.includes(searchLower);
            });
            console.log("After search filter:", filtered.length);
          }

          console.log("Final filtered issues:", filtered.length);
          return filtered;
        }

        function renderResults(issues = [], resetFilters = false, options = {}) {
          const { skipSave = false, restoreTimestamp = null } = options;
          
          // Switch to issues tab and update badge
          switchToTab("issues");
          document.getElementById("issues-count").textContent = issues.length;
          
          // Store report data
          const isNewData = currentReportData.issues !== issues;
          currentReportData.issues = issues;
          // Don't clear tokens - keep it
          // currentReportData.tokens = null;
          const timestamp = restoreTimestamp || new Date().toISOString();
          currentReportData.timestamp = timestamp;
          isViewingTokens = false;
          
          // Only reset filters if this is new data or explicitly requested
          if (resetFilters || isNewData) {
            console.log("Resetting filters for new data");
            currentFilter = "all";
            currentColorTypeFilter = "all";
            if (searchInput) {
              searchInput.value = "";
            }
            currentSearch = "";
            if (btnClearSearch) {
              btnClearSearch.style.display = "none";
            }
            if (filterButtons && filterButtons.length > 0) {
              filterButtons.forEach(btn => {
                btn.classList.remove("active");
                if (btn.getAttribute("data-filter") === "all") {
                  btn.classList.add("active");
                }
              });
            }
          }
          
          // Show filter controls
          const filterControls = document.getElementById("filter-controls");
          const colorTypeFilter = document.getElementById("color-type-filter");
          const filterButtonsContainer = document.getElementById("filter-buttons");
          filterControls.style.display = issues.length > 0 ? "flex" : "none";
          colorTypeFilter.style.display = "none";
          filterButtonsContainer.style.display = "flex";
          
          const exportGroup = document.getElementById("export-group");
          exportGroup.style.display = issues.length > 0 ? "flex" : "none";

          // Filter issues - use current filter/search values
          console.log("About to filter with:", { currentFilter, currentSearch });
          const filteredIssues = filterAndSearchIssues(issues);
          
          clearResults("issues");

          if (filteredIssues.length === 0) {
            if (issues.length === 0) {
              resultsIssues.innerHTML = `
                <div class="empty-state success">
                  <div class="icon">‚úÖ</div>
                  <p><strong>No issues found!</strong></p>
                  <p style="margin-top: 8px; font-size: 12px;">Your design passed all configured checks.</p>
                </div>
              `;
            } else {
              resultsIssues.innerHTML = `
                <div class="empty-state">
                  <div class="icon">üîç</div>
                  <p><strong>No results found</strong></p>
                  <p style="margin-top: 8px; font-size: 12px;">Try changing the filter or search keyword.</p>
                </div>
              `;
            }
            return;
          }

          // Calculate stats from filtered issues
          const stats = {
            error: filteredIssues.filter(i => i.severity === "error").length,
            warn: filteredIssues.filter(i => i.severity === "warn").length,
            total: filteredIssues.length,
            originalTotal: issues.length
          };

          // Results header
          const header = document.createElement("div");
          header.className = "results-header";
          header.innerHTML = `
            <h3>Check Result</h3>
            <div class="results-stats">
              ${stats.error > 0 ? `<span class="stat error">${stats.error} Error</span>` : ""}
              ${stats.warn > 0 ? `<span class="stat warn">${stats.warn} Warning</span>` : ""}
              <span class="stat">${stats.total} Total</span>
              ${stats.originalTotal !== stats.total ? `<span class="stat" style="opacity: 0.6;">(${stats.originalTotal} total)</span>` : ""}
            </div>
          `;
          resultsIssues.appendChild(header);

          // Group filtered issues by type
          const grouped = filteredIssues.reduce((acc, i) => {
            acc[i.type] = acc[i.type] || [];
            acc[i.type].push(i);
            return acc;
          }, {});

          // Define all possible issue types (to show even when count = 0)
          const allIssueTypes = [
            "naming", "autolayout", "spacing", "color", "typography", "typography-style", "typography-check",
            "line-height", "position", "duplicate", "group", "component",
            "empty-frame", "nested-group", "contrast", "text-size-mobile"
          ];

          // Render all issue types (including those with 0 issues)
          for (const type of allIssueTypes) {
            const issueCount = grouped[type] ? grouped[type].length : 0;
            
            // Skip if no issues and no original issues (first scan)
            if (issueCount === 0 && issues.length === 0) {
              continue; // Don't show empty groups on first scan with no issues
            }
            
            // Hide groups with 0 count when filtering by error or warning
            if (issueCount === 0 && currentFilter !== "all") {
              continue; // Skip empty groups when filtering
            }
            const groupEl = document.createElement("div");
            groupEl.className = "issue-group collapsed"; // Default collapsed
            
            const groupHeader = document.createElement("div");
            groupHeader.className = "issue-group-header";
            groupHeader.innerHTML = `
              <div class="issue-group-header-left">
                <button class="issue-group-toggle" type="button">
                  <span class="issue-group-toggle-icon">‚ñº</span>
                </button>
                <h4>${getTypeIcon(type)} ${getTypeDisplayName(type)}</h4>
                <span class="badge">${issueCount}</span>
              </div>
              ${issueCount > 0 ? `<button class="btn-fix-all" data-type="${type}">Fix all now</button>` : ""}
            `;
            
            // Add click handler for collapse/expand
            const toggleBtn = groupHeader.querySelector(".issue-group-toggle");
            const toggleCollapse = () => {
              const isCollapsed = groupEl.classList.contains("collapsed");
              if (isCollapsed) {
                groupEl.classList.remove("collapsed");
                groupContent.style.display = "block";
                setTimeout(() => {
                  groupContent.style.opacity = "1";
                }, 10);
              } else {
                groupContent.style.opacity = "0";
                setTimeout(() => {
                  groupEl.classList.add("collapsed");
                  groupContent.style.display = "none";
                }, 200);
              }
            };
            
            toggleBtn.onclick = (e) => {
              e.stopPropagation();
              toggleCollapse();
            };
            
            groupHeader.onclick = (e) => {
              if (e.target !== toggleBtn && !toggleBtn.contains(e.target)) {
                toggleCollapse();
              }
            };
            
            groupEl.appendChild(groupHeader);

            // Create content wrapper - start hidden
            const groupContent = document.createElement("div");
            groupContent.className = "issue-group-content";
            groupContent.style.display = "none"; // Start hidden

            if (issueCount === 0) {
              // Show "No issues" message for empty groups
              const emptyMsg = document.createElement("div");
              emptyMsg.className = "issue info";
              emptyMsg.style.opacity = "0.7";
              emptyMsg.innerHTML = `
                <div class="issue-header">
                  <div>
                    <span class="issue-type">‚úÖ PASSED</span>
                    <div class="issue-body">No issues in this type.</div>
                  </div>
                </div>
              `;
              groupContent.appendChild(emptyMsg);
            } else {
              // Render issues
              grouped[type].forEach((issue, index) => {
              const issueNumber = index + 1;
              
              // Use addIssueEl for typography issues to get detailed rendering
              if (issue.type === "typography-check") {
                const tempDiv = document.createElement("div");
                groupContent.appendChild(tempDiv);
                
                // Call addIssueEl and move the created element into groupContent
                const issueEl = addIssueEl(issue);
                if (issueEl) {
                  // Add issue number
                  const numberSpan = document.createElement("span");
                  numberSpan.className = "issue-number";
                  numberSpan.textContent = `#${issueNumber}`;
                  numberSpan.style.cssText = "position: absolute; left: 8px; top: 8px; font-weight: bold; opacity: 0.5; font-size: 11px;";
                  issueEl.style.position = "relative";
                  issueEl.style.paddingLeft = "40px";
                  issueEl.insertBefore(numberSpan, issueEl.firstChild);
                  groupContent.replaceChild(issueEl, tempDiv);
                }
                return;
              }
              
              const issueEl = document.createElement("div");
              issueEl.className = `issue ${issue.severity}`;
              issueEl.setAttribute("data-issue-id", issue.id);
              // Build issue body with additional info for contrast issues
              let issueBody = escapeHtml(issue.message);
              if (issue.type === "contrast") {
                const details = [];
                if (issue.textColor) {
                  details.push(`Text color: <code style="background: ${escapeHtml(issue.textColor)}; padding: 2px 6px; border-radius: 3px; color: ${getContrastTextColor(issue.textColor)};">${escapeHtml(issue.textColor)}</code> (${issue.textColorNode || issue.nodeName || "Unnamed"})`);
                }
                if (issue.backgroundColor) {
                  let bgLabel = "Background:";
                  let bgValue = "";
                  let bgNote = "";
                  
                  if (issue.isGradient && issue.gradientString) {
                    // Show full gradient string
                    bgLabel = `Background (gradient):`;
                    bgValue = `<code style="background: ${escapeHtml(issue.backgroundColor)}; padding: 2px 6px; border-radius: 3px; color: ${getContrastTextColor(issue.backgroundColor)}; font-family: 'SF Mono', Monaco, monospace; font-size: 11px;">${escapeHtml(issue.gradientString)}</code>`;
                    bgNote = " <span style='font-size: 11px; color: #999;'>(average: " + escapeHtml(issue.backgroundColor) + ")</span>";
                  } else {
                    // Show solid color
                    bgValue = `<code style="background: ${escapeHtml(issue.backgroundColor)}; padding: 2px 6px; border-radius: 3px; color: ${getContrastTextColor(issue.backgroundColor)};">${escapeHtml(issue.backgroundColor)}</code>`;
                  }
                  
                  if (issue.fromSibling) {
                    bgNote += " <span style='font-size: 11px; color: #3b82f6;'>(from sibling layer)</span>";
                  }
                  
                  details.push(`${bgLabel} ${bgValue}${bgNote} (${issue.backgroundColorNode || "Unknown"})`);
                }
                if (details.length > 0) {
                  issueBody += `<div style="margin-top: 8px; font-size: 12px; color: #666;">${details.join(" | ")}</div>`;
                }
              }
              
              issueEl.innerHTML = `
                <div class="issue-header">
                  <div>
                    <span class="issue-type">
                      <span class="issue-number">#${issueNumber}</span>
                      ${getSeverityIcon(issue.severity)} ${issue.severity.toUpperCase()}
                    </span>
                    <div class="issue-body">${issueBody}</div>
                    ${issue.nodeName ? `<div class="issue-node">Node: ${escapeHtml(issue.nodeName)}</div>` : ""}
                  </div>
                  <div class="issue-actions">
                    <button class="btn-select" data-id="${issue.id}">Select</button>
                    ${issue.type === "color" ? `<button class="btn-fix" data-id="${issue.id}">Fix now</button>` : ""}
                    ${issue.type === "spacing" ? `<button class="btn-fix" data-id="${issue.id}">Fix now</button>` : ""}
                    ${issue.type === "typography-style" ? `
                      ${issue.bestMatch ? `
                        <div class="style-suggest-container" style="display: inline-flex; gap: 6px; align-items: center;">
                          <button class="btn-suggest-apply" data-id="${issue.id}" data-style-name="${escapeHtml(issue.bestMatch.name)}">Suggest Apply</button>
                          <div class="style-dropdown-wrapper" style="position: relative;">
                            <button class="btn-style-dropdown" data-id="${issue.id}" data-issue-id="${issue.id}">Choose Style ‚ñº</button>
                            <div class="style-dropdown-menu" data-issue-id="${issue.id}" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 4px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 1000; min-width: 150px; max-height: 200px; overflow-y: auto;">
                              <div style="padding: 8px 12px; color: #999; font-size: 12px; text-align: center;">Loading...</div>
                            </div>
                          </div>
                        </div>
                      ` : `
                        <div class="style-dropdown-wrapper" style="position: relative; display: inline-block;">
                          <button class="btn-style-dropdown" data-id="${issue.id}" data-issue-id="${issue.id}">Choose Style ‚ñº</button>
                          <div class="style-dropdown-menu" data-issue-id="${issue.id}" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 4px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 1000; min-width: 150px; max-height: 200px; overflow-y: auto;">
                            <div style="padding: 8px 12px; color: #999; font-size: 12px; text-align: center;">Loading...</div>
                          </div>
                        </div>
                      `}
                      <button class="btn-create-style" data-id="${issue.id}" data-issue-type="${issue.type}">Create Style</button>
                    ` : ""}
                  </div>
                </div>
              `;
              groupContent.appendChild(issueEl);
              
              // Store issue data on element for later access
              issueEl.setAttribute("data-issue-id", issue.id);
              issueEl.setAttribute("data-issue-type", issue.type);
              
              const btn = issueEl.querySelector("button.btn-select");
              if (btn) {
                btn.onclick = () => {
                  parent.postMessage({ pluginMessage: { type: "select-node", id: issue.id } }, "*");
                };
              }
              
              const btnFix = issueEl.querySelector("button.btn-fix");
              if (btnFix) {
                if (issue.type === "color") {
                  btnFix.onclick = () => {
                    handleFixColorIssue(issue);
                  };
                } else if (issue.type === "spacing") {
                  btnFix.onclick = () => {
                    handleFixSpacingIssue(issue);
                  };
                } else {
                  btnFix.onclick = () => {
                    handleFixIssue(issue);
                  };
                }
              }
              
              // Handle Create Style button for typography-style issues
              if (issue.type === "typography-style") {
                const btnCreateStyle = issueEl.querySelector("button.btn-create-style");
                if (btnCreateStyle) {
                  console.log("Attaching create style handler to button", { issueId: issue.id, issueType: issue.type, nodeName: issue.nodeName });
                  // Create a closure to capture the issue
                  (function(issueData) {
                    btnCreateStyle.onclick = (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      console.log("Create Style button clicked", issueData);
                      if (typeof handleCreateTextStyle === "function") {
                        handleCreateTextStyle(issueData);
                      } else {
                        console.error("handleCreateTextStyle is not a function");
                        alert("Error: handleCreateTextStyle function not found");
                      }
                    };
                  })(issue);
                } else {
                  console.error("Create Style button not found in DOM", { 
                    issueId: issue.id, 
                    issueType: issue.type, 
                    hasIssueEl: !!issueEl,
                    innerHTML: issueEl.innerHTML.substring(0, 200)
                  });
                }
                
                // Handle Suggest Apply button
                const btnSuggestApply = issueEl.querySelector("button.btn-suggest-apply");
                if (btnSuggestApply && issue.bestMatch) {
                  (function(issueData) {
                    btnSuggestApply.onclick = (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      const styleName = btnSuggestApply.getAttribute("data-style-name");
                      handleApplyTypographyStyle(issueData, styleName);
                    };
                  })(issue);
                }
                
                // Handle Style Dropdown
                const btnStyleDropdown = issueEl.querySelector("button.btn-style-dropdown");
                const dropdownMenu = issueEl.querySelector(".style-dropdown-menu");
                if (btnStyleDropdown && dropdownMenu) {
                  let stylesLoaded = false;
                  
                  // Toggle dropdown
                  btnStyleDropdown.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const isVisible = dropdownMenu.style.display !== "none";
                    
                    // Close all other dropdowns
                    document.querySelectorAll(".style-dropdown-menu").forEach(menu => {
                      if (menu !== dropdownMenu) {
                        menu.style.display = "none";
                      }
                    });
                    
                    if (!isVisible) {
                      // Open dropdown
                      dropdownMenu.style.display = "block";
                      
                      // Load styles if not loaded yet
                      if (!stylesLoaded) {
                        dropdownMenu.innerHTML = '<div style="padding: 8px 12px; color: #999; font-size: 12px; text-align: center;">Loading...</div>';
                        
                        // Request text styles from Figma
                        parent.postMessage({
                          pluginMessage: {
                            type: "get-figma-text-styles",
                            issueId: issue.id
                          }
                        }, "*");
                      }
                    } else {
                      dropdownMenu.style.display = "none";
                    }
                  };
                  
                  // Close dropdown when clicking outside
                  document.addEventListener("click", function closeDropdown(e) {
                    if (!issueEl.contains(e.target)) {
                      dropdownMenu.style.display = "none";
                    }
                  });
                }
              }
              });
            }

            groupEl.appendChild(groupContent);
            resultsIssues.appendChild(groupEl);
          }

          if (!skipSave) {
            // Save both reports together
            saveLastReport({
              issues,
              issuesTimestamp: timestamp,
              tokens: currentReportData.tokens,
              tokensTimestamp: currentReportData.tokensTimestamp,
              lastActiveTab: "issues",
              scanMode: currentReportData.scanMode || null,
              context: currentReportData.context || null
            });
          }
        }

        function filterAndSearchTokens(tokens) {
          console.log("filterAndSearchTokens called", { 
            hasTokens: !!tokens, 
            currentColorTypeFilter, 
            currentSearch 
          });
          if (!tokens) return null;

          const filtered = {};
          let hasMatches = false;
          
          for (const [key, values] of Object.entries(tokens)) {
            let filteredValues = values || [];
            console.log(`Processing ${key}, initial count:`, filteredValues.length);

            // Filter by color type (for colors and gradients)
            if ((key === "colors" || key === "gradients") && currentColorTypeFilter !== "all") {
              filteredValues = filteredValues.filter(token => {
                const colorType = token.colorType || "";
                return colorType.toLowerCase().includes(currentColorTypeFilter.toLowerCase());
              });
              console.log(`After color type filter (${currentColorTypeFilter}):`, filteredValues.length);
            }

            // Search - search in all relevant fields and mark match source
            if (currentSearch.trim()) {
              const searchLower = currentSearch.toLowerCase();
              filteredValues = filteredValues.map(token => {
                const value = String(token.value || "").toLowerCase();
                const nodeNames = (token.nodes || []).map(n => n.name || "").join(" ").toLowerCase();
                const colorType = (token.colorType || "").toLowerCase();
                
                // Check where the match occurs
                const valueMatch = value.includes(searchLower);
                const nodeNameMatch = nodeNames.includes(searchLower);
                const colorTypeMatch = colorType.includes(searchLower);
                
                // If matches, add matchedBy field to indicate why it matched
                if (valueMatch || nodeNameMatch || colorTypeMatch) {
                  const matchedBy = [];
                  if (valueMatch) matchedBy.push("value");
                  if (nodeNameMatch) matchedBy.push("nodeName");
                  if (colorTypeMatch) matchedBy.push("colorType");
                  
                  return {
                    ...token,
                    _matchedBy: matchedBy,
                    _matchedNodeNames: nodeNameMatch ? (token.nodes || []).filter(n => 
                      (n.name || "").toLowerCase().includes(searchLower)
                    ).map(n => n.name) : []
                  };
                }
                return null;
              }).filter(token => token !== null);
              console.log(`After search filter (${key}):`, filteredValues.length);
            }

            if (filteredValues.length > 0) {
              hasMatches = true;
            }

            filtered[key] = filteredValues;
          }

          console.log("Final filtered tokens keys:", Object.keys(filtered));
          return { tokens: filtered, hasMatches };
        }

        function replaceSpacingScaleWithTokens(tokens) {
          const input = document.getElementById("spacing-scale");
          if (!input) return;
          const list = (tokens && Array.isArray(tokens.spacing)) ? tokens.spacing : [];
          const values = list
            .map(t => {
              const num = parseInt(String(t && t.value !== undefined ? t.value : "").trim(), 10);
              // Always use absolute value (convert negative to positive)
              return isNaN(num) ? null : Math.abs(num);
            })
            .filter(n => n !== null);

          if (!values.length) return;
          // Remove duplicates and sort ascending
          const next = Array.from(new Set(values)).sort((a, b) => a - b);
          input.value = next.join(", ");

          // Visual feedback
          try {
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
          } catch (e) {
            // ignore
          }
        }

        function renderTokens(tokens, resetFilters = false, options = {}) {
          const { skipSave = false, restoreTimestamp = null } = options;
          
          // Switch to tokens tab and update badge
          switchToTab("tokens");
          let totalTokensCount = Object.values(tokens || {}).reduce((sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0), 0);
          document.getElementById("tokens-count").textContent = totalTokensCount;
          
          // Store report data
          const isNewData = currentReportData.tokens !== tokens;
          // Don't clear issues - keep it
          // currentReportData.issues = null;
          currentReportData.tokens = tokens;
          const timestamp = restoreTimestamp || new Date().toISOString();
          currentReportData.tokensTimestamp = timestamp;
          isViewingTokens = true;
          
          // Only reset filters if this is new data or explicitly requested
          if (resetFilters || isNewData) {
            console.log("Resetting filters for new token data");
            currentFilter = "all";
            currentColorTypeFilter = "all";
            if (searchInput) {
              searchInput.value = "";
            }
            currentSearch = "";
            if (btnClearSearch) {
              btnClearSearch.style.display = "none";
            }
            if (filterButtons && filterButtons.length > 0) {
              filterButtons.forEach(btn => {
                btn.classList.remove("active");
                if (btn.getAttribute("data-filter") === "all") {
                  btn.classList.add("active");
                }
              });
            }
            if (colorTypeSelect) {
              colorTypeSelect.value = "all";
            }
          }
          
          // Show filter controls
          const filterControls = document.getElementById("filter-controls");
          const colorTypeFilter = document.getElementById("color-type-filter");
          const filterButtonsContainer = document.getElementById("filter-buttons");
          filterControls.style.display = tokens && Object.keys(tokens).length > 0 ? "flex" : "none";
          colorTypeFilter.style.display = (tokens && (tokens.colors || tokens.gradients)) ? "block" : "none";
          filterButtonsContainer.style.display = "none"; // Hide severity filter for tokens
          
          const exportGroup = document.getElementById("export-group");
          exportGroup.style.display = tokens && Object.keys(tokens).length > 0 ? "flex" : "none";

          // Filter tokens - use current filter/search values
          console.log("About to filter tokens with:", { currentColorTypeFilter, currentSearch });
          const filterResult = filterAndSearchTokens(tokens);
          
          clearResults("tokens");

          if (!tokens || Object.keys(tokens).length === 0) {
            resultsTokens.innerHTML = `
              <div class="empty-state">
                <div class="icon">üìã</div>
                <p>No design tokens found</p>
              </div>
            `;
            return;
          }

          if (!filterResult) {
            resultsTokens.innerHTML = `
              <div class="empty-state">
                <div class="icon">üîç</div>
                <p><strong>No results found</strong></p>
                <p style="margin-top: 8px; font-size: 12px;">Try changing the filter or search keyword.</p>
              </div>
            `;
            return;
          }

          const filteredTokens = filterResult.tokens || {};
          const hasTokenMatches = filterResult.hasMatches;
          const isSearchActive = currentSearch.trim() || currentColorTypeFilter !== "all";

          if (isSearchActive && !hasTokenMatches) {
            resultsTokens.innerHTML = `
              <div class="empty-state">
                <div class="icon">üîç</div>
                <p><strong>No results found</strong></p>
                <p style="margin-top: 8px; font-size: 12px;">Try changing the filter or search keyword.</p>
              </div>
            `;
            return;
          }

            const tokenGroups = {
              colors: { icon: "üé®", label: "Colors", values: filteredTokens.colors || [] },
              gradients: { icon: "üåà", label: "Gradients", values: filteredTokens.gradients || [] },
              spacing: { icon: "‚ÜîÔ∏è", label: "Spacing (px)", values: filteredTokens.spacing || [] },
              borderRadius: { icon: "‚≠ï", label: "Border Radius", values: filteredTokens.borderRadius || [] },
              fontWeight: { icon: "üí™", label: "Font Weight", values: filteredTokens.fontWeight || [] },
              lineHeight: { icon: "üìè", label: "Line Height (%)", values: filteredTokens.lineHeight || [] },
              fontSize: { icon: "üìù", label: "Font Size", values: filteredTokens.fontSize || [] },
              fontFamily: { icon: "üî§", label: "Font Family", values: filteredTokens.fontFamily || [] }
            };

          // Results header
          const header = document.createElement("div");
          header.className = "results-header";
          const totalTokens = Object.values(tokenGroups).reduce((sum, group) => sum + group.values.length, 0);
          header.innerHTML = `
            <h3>Design Tokens</h3>
            <div class="results-stats">
              <span class="stat">${totalTokens} Tokens</span>
            </div>
          `;
          resultsTokens.appendChild(header);

          // Render token groups
          for (const [key, group] of Object.entries(tokenGroups)) {
            const groupEl = document.createElement("div");
            groupEl.className = "issue-group collapsed"; // Default collapsed
            
            const groupHeader = document.createElement("div");
            groupHeader.className = "issue-group-header";
            groupHeader.innerHTML = `
              <div class="issue-group-header-left">
                <button class="issue-group-toggle" type="button">
                  <span class="issue-group-toggle-icon">‚ñº</span>
                </button>
                <h4>${group.icon} ${group.label}</h4>
                <span class="badge">${group.values.length}</span>
              </div>
            `;
            
            // Create content wrapper - start hidden
            const groupContent = document.createElement("div");
            groupContent.className = "issue-group-content";
            groupContent.style.display = "none";

            // Add click handler for collapse/expand
            const toggleBtn = groupHeader.querySelector(".issue-group-toggle");
            const toggleCollapse = () => {
              const isCollapsed = groupEl.classList.contains("collapsed");
              if (isCollapsed) {
                groupEl.classList.remove("collapsed");
                groupContent.style.display = "block";
                setTimeout(() => {
                  groupContent.style.opacity = "1";
                }, 10);
              } else {
                groupContent.style.opacity = "0";
                setTimeout(() => {
                  groupEl.classList.add("collapsed");
                  groupContent.style.display = "none";
                }, 200);
              }
            };
            
            toggleBtn.onclick = (e) => {
              e.stopPropagation();
              toggleCollapse();
            };
            
            groupHeader.onclick = (e) => {
              if (e.target !== toggleBtn && !toggleBtn.contains(e.target)) {
                toggleCollapse();
              }
            };
            
            groupEl.appendChild(groupHeader);

            const hasValues = Array.isArray(group.values) && group.values.length > 0;

            if (hasValues) {
              const tokenList = document.createElement("div");
              tokenList.className = "token-list";

              group.values.forEach((token, idx) => {
              const tokenNumber = idx + 1;
              const tokenEl = document.createElement("div");
              tokenEl.className = "token-item";
              
              // token is now an object: {value, nodes: [{id, name}], colorType}
              const tokenValue = token.value;
              const nodes = token.nodes || [];
              const firstNode = nodes.length > 0 ? nodes[0] : null;
              const nodeCount = nodes.length;
              const colorType = token.colorType || null;
              
              let valueHtml = "";
              // Special handling for colors
              if (key === "colors") {
                const colorTypeBadge = colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : "";
                valueHtml = `
                  <span class="token-number">#${tokenNumber}</span>
                  <span class="token-color-preview" style="background-color: ${escapeHtml(tokenValue)}"></span>
                  <code>${escapeHtml(tokenValue)}</code>
                  ${colorTypeBadge}
                `;
              } else if (key === "gradients") {
                const colorTypeBadge = colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : "";
                valueHtml = `
                  <span class="token-number">#${tokenNumber}</span>
                  <span class="token-gradient-preview" style="background: ${escapeHtml(tokenValue)}"></span>
                  <code>${escapeHtml(tokenValue)}</code>
                  ${colorTypeBadge}
                `;
              } else {
                valueHtml = `<span class="token-number">#${tokenNumber}</span><code>${escapeHtml(String(tokenValue))}</code>`;
              }
              
              // Check if this token matched by node name in search
              const matchedBy = token._matchedBy || [];
              const matchedNodeNames = token._matchedNodeNames || [];
              const isMatchedByNodeName = matchedBy.includes("nodeName");
              
              // Show matched node names if search matched by node name
              let nodeNameDisplay = "";
              if (firstNode && firstNode.name) {
                if (isMatchedByNodeName && matchedNodeNames.length > 0) {
                  // Highlight matched node names
                  const matchedNamesHtml = matchedNodeNames.map(name => 
                    `<span class="token-matched-node">${escapeHtml(name)}</span>`
                  ).join(", ");
                  nodeNameDisplay = `<div class="token-node-name token-matched-by-name">
                    <span class="match-indicator">üîç Matched in:</span> ${matchedNamesHtml}
                  </div>`;
                } else {
                  nodeNameDisplay = `<div class="token-node-name">Node: ${escapeHtml(firstNode.name)}</div>`;
                }
              }

              // Extra note for Font Weight: show font-family usage breakdown
              let noteHtml = "";
              if (key === "fontWeight") {
                const fontFamilies = Array.isArray(token.fontFamilies) ? token.fontFamilies : null;
                let list = fontFamilies;
                if (!list) {
                  // Fallback (older data): compute from nodes
                  const counts = {};
                  nodes.forEach(n => {
                    const fam = (n && n.fontFamily) ? String(n.fontFamily) : "Unknown";
                    counts[fam] = (counts[fam] || 0) + 1;
                  });
                  list = Object.entries(counts)
                    .map(([family, count]) => ({ family, count }))
                    .sort((a, b) => (b.count - a.count) || a.family.localeCompare(b.family));
                }
                if (Array.isArray(list) && list.length > 0) {
                  const items = list
                    .map(x => `<li><code>${escapeHtml(x.family)}</code> (${x.count})</li>`)
                    .join("");
                  noteHtml = `
                    <div class="token-note">
                      <div class="token-note-label">Font-family:</div>
                      <ul class="token-note-list">${items}</ul>
                    </div>
                  `;
                }
              }
              
              tokenEl.innerHTML = `
                <div class="token-item-row">
                  <div class="token-value">
                    ${valueHtml}
                  </div>
                  ${firstNode ? `
                    <div class="token-actions">
                      <button class="btn-select" data-id="${firstNode.id}">Select</button>
                      ${nodeCount > 1 ? `<span class="token-node-count">(${nodeCount})</span>` : ""}
                    </div>
                  ` : ""}
                </div>
                ${nodeNameDisplay}
                ${noteHtml}
              `;
              
              // Add click handler for Select button
              const btn = tokenEl.querySelector("button.btn-select");
              if (btn) {
                btn.onclick = () => {
                  parent.postMessage({ pluginMessage: { type: "select-node", id: firstNode.id } }, "*");
                };
              }

                tokenList.appendChild(tokenEl);
              });

              groupContent.appendChild(tokenList);
            } else {
              const emptyMsg = document.createElement("div");
              emptyMsg.className = "token-empty-message";
              emptyMsg.textContent = "No tokens in this group.";
              groupContent.appendChild(emptyMsg);
            }
            groupEl.appendChild(groupContent);
            resultsTokens.appendChild(groupEl);
          }

          if (!skipSave) {
            // Save both reports together
            saveLastReport({
              issues: currentReportData.issues,
              issuesTimestamp: currentReportData.timestamp,
              tokens,
              tokensTimestamp: timestamp,
              lastActiveTab: "tokens",
              scanMode: currentReportData.scanMode || null,
              context: currentReportData.context || null
            });
          }
        }

  // Helper function to show validation error
  function showValidationError(message) {
    const validationError = document.getElementById("validation-error");
    const validationErrorMessage = document.getElementById("validation-error-message");
    const btnCloseValidationError = document.getElementById("btn-close-validation-error");
    
    if (validationError && validationErrorMessage) {
      validationErrorMessage.textContent = message;
      validationError.style.display = "block";
      
      // Hide scan progress and cancel button
      btnScan.style.display = "block";
      btnCancelScan.style.display = "none";
      scanProgress.style.display = "none";
      btnScan.disabled = false;
      btnExtractTokens.disabled = false;
      
      // Auto-hide after 10 seconds
      setTimeout(() => {
        if (validationError.style.display === "block") {
          validationError.style.display = "none";
        }
      }, 10000);
      
      // Close button handler
      if (btnCloseValidationError) {
        btnCloseValidationError.onclick = () => {
          validationError.style.display = "none";
        };
      }
    }
  }

  btnScan.onclick = () => {
    console.log("btnScan clicked");
    try {
      // Hide validation error if visible
      const validationError = document.getElementById("validation-error");
      if (validationError) {
        validationError.style.display = "none";
      }
      
      // Show cancel button and progress, hide scan button
      btnScan.style.display = "none";
      btnCancelScan.style.display = "block";
      scanProgress.style.display = "block";
      // Force reset progress bar
      scanProgressBar.style.transition = "none";
      scanProgressBar.style.width = "0%";
      scanProgressText.textContent = "0%";
      // Re-enable transition after reset
      setTimeout(() => {
        scanProgressBar.style.transition = "width 0.3s";
      }, 10);
      
      // Don't clear - keep both tabs' content
      // clearResults();
      const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";
      const spacingScaleInput = document.getElementById("spacing-scale");
      const spacingThresholdInput = document.getElementById("spacing-threshold");
      const colorScaleInput = document.getElementById("color-scale");
      const fontSizeScaleInput = document.getElementById("font-size-scale");
      const fontSizeThresholdInput = document.getElementById("font-size-threshold");
      const lineHeightScaleInput = document.getElementById("line-height-scale");
      const lineHeightThresholdInput = document.getElementById("line-height-threshold");
      const lineHeightBaselineThresholdInput = document.getElementById("line-height-baseline-threshold");
      
      let spacingScaleValue = spacingScaleInput ? spacingScaleInput.value.trim() : "";
      const spacingThreshold = spacingThresholdInput ? parseInt(spacingThresholdInput.value, 10) : 100;
      let colorScaleValue = colorScaleInput ? colorScaleInput.value.trim() : "";
      let fontSizeScaleValue = fontSizeScaleInput ? fontSizeScaleInput.value.trim() : "";
      const fontSizeThreshold = fontSizeThresholdInput ? parseInt(fontSizeThresholdInput.value, 10) : 100;
      let lineHeightScaleValue = lineHeightScaleInput ? lineHeightScaleInput.value.trim() : "";
      const lineHeightThreshold = lineHeightThresholdInput ? parseInt(lineHeightThresholdInput.value, 10) : 300;
      const lineHeightBaselineThreshold = lineHeightBaselineThresholdInput ? parseInt(lineHeightBaselineThresholdInput.value, 10) : 120;
      
      // Validate spacing guidelines format if not empty
      if (spacingScaleValue) {
        const formatRegex = /^\d+(\s*,\s*\d+)*$/;
        if (!formatRegex.test(spacingScaleValue)) {
          showValidationError("Spacing guidelines format is incorrect. Please enter the numbers separated by commas (e.g. 4, 8, 12, 16)");
          return;
        }
      }
      
      // Validate color format if not empty (allow hex only)
      if (colorScaleValue) {
        // Split by comma and validate each color
        const colors = colorScaleValue.split(",").map(c => c.trim()).filter(c => c);
        const colorRegex = /^#[0-9a-fA-F]{3,8}$/;
        const invalidColors = colors.filter(c => !colorRegex.test(c));
        if (invalidColors.length > 0) {
          showValidationError(`Color format is incorrect. Invalid colors: ${invalidColors.join(", ")}. Please use hex format only (e.g., #000000, #FFFFFF).`);
          return;
        }
      }
      
      // Validate font-size scale format if not empty
      if (fontSizeScaleValue) {
        const formatRegex = /^\d+(\s*,\s*\d+)*$/;
        if (!formatRegex.test(fontSizeScaleValue)) {
          showValidationError("Font-size scale format is incorrect. Please enter the numbers separated by commas (e.g. 32, 24, 20, 18)");
          return;
        }
      }
      
      // Validate line-height scale format if not empty (allow "auto" keyword anywhere)
      if (lineHeightScaleValue) {
        // Split by comma and check each value
        const values = lineHeightScaleValue.split(",").map(v => v.trim()).filter(v => v);
        const isValid = values.every(v => {
          return v.toLowerCase() === "auto" || /^\d+$/.test(v);
        });
        
        if (!isValid || values.length === 0) {
          showValidationError('Line-height scale format is incorrect. Please enter "auto" and/or numbers separated by commas. "auto" can be placed anywhere (e.g. auto, 100, 120 or 100, auto, 150)');
          return;
        }
      }
      
      // Validate thresholds
      if (isNaN(spacingThreshold) || spacingThreshold < 0) {
        showValidationError("Spacing threshold must be a number >= 0");
        return;
      }
      
      if (isNaN(fontSizeThreshold) || fontSizeThreshold < 0) {
        showValidationError("Font-size threshold must be a number >= 0");
        return;
      }
      
      if (isNaN(lineHeightThreshold) || lineHeightThreshold < 0) {
        showValidationError("Line-height threshold must be a number >= 0");
        return;
      }
      
      if (isNaN(lineHeightBaselineThreshold) || lineHeightBaselineThreshold < 0) {
        showValidationError("Line-height baseline threshold must be a number >= 0");
        return;
      }
      
      // Don't save to history here - wait for actual results
      
      resultsIssues.innerHTML = `
        <div class="scanning">
          <div class="spinner"></div>
          <p>Scanning design... Please wait</p>
        </div>
      `;
      switchToTab("issues");
      btnScan.disabled = true;
      btnExtractTokens.disabled = true;
      currentReportData.scanMode = scope;
      
      // Save input values before scanning
      saveInputValues();
      
      // Get Typography settings
      const typographyRules = {
        checkStyle: document.getElementById("rule-typo-style")?.checked || false,
        checkFontFamily: document.getElementById("rule-font-family")?.checked || false,
        checkFontSize: document.getElementById("rule-font-size")?.checked || false,
        checkFontWeight: document.getElementById("rule-font-weight")?.checked || false,
        checkLineHeight: document.getElementById("rule-line-height")?.checked || false,
        checkLetterSpacing: document.getElementById("rule-letter-spacing")?.checked || false,
        checkWordSpacing: document.getElementById("rule-word-spacing")?.checked || false
      };
      
      parent.postMessage({ 
        pluginMessage: { 
          type: "scan", 
          mode: scope, 
          spacingScale: spacingScaleValue, 
          spacingThreshold: spacingThreshold,
          colorScale: colorScaleValue,
          fontSizeScale: fontSizeScaleValue,
          fontSizeThreshold: fontSizeThreshold,
          lineHeightScale: lineHeightScaleValue,
          lineHeightThreshold: lineHeightThreshold,
          lineHeightBaselineThreshold: lineHeightBaselineThreshold,
          typographyStyles: typographyStyles,
          typographyRules: typographyRules
        } 
      }, "*");
      console.log("Message sent:", { type: "scan", mode: scope });
    } catch (error) {
      console.error("Error in btnScan.onclick:", error);
      resultsIssues.innerHTML = `<div class="error-message">Error: ${escapeHtml(error.message)}</div>`;
      switchToTab("issues");
      btnScan.disabled = false;
      btnExtractTokens.disabled = false;
    }
  };

  btnExtractTokens.onclick = () => {
    console.log("btnExtractTokens clicked");
    try {
      // Show cancel button and progress, hide extract button
      btnExtractTokens.style.display = "none";
      btnCancelScan.style.display = "block";
      scanProgress.style.display = "block";
      // Force reset progress bar
      scanProgressBar.style.transition = "none";
      scanProgressBar.style.width = "0%";
      scanProgressText.textContent = "0%";
      // Re-enable transition after reset
      setTimeout(() => {
        scanProgressBar.style.transition = "width 0.3s";
      }, 10);
      
      // Don't clear - keep both tabs' content
      // clearResults();
      const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";

      // Don't save to history here - wait for actual results

      resultsTokens.innerHTML = `
        <div class="scanning">
          <div class="spinner"></div>
          <p>Extracting design tokens... Please wait</p>
        </div>
      `;
      switchToTab("tokens");
      btnScan.disabled = true;
      btnExtractTokens.disabled = true;
      currentReportData.scanMode = scope;
      parent.postMessage({ pluginMessage: { type: "extract-tokens", mode: scope } }, "*");
      console.log("Message sent:", { type: "extract-tokens", mode: scope });
    } catch (error) {
      console.error("Error in btnExtractTokens.onclick:", error);
      resultsTokens.innerHTML = `<div class="error-message">Error: ${escapeHtml(error.message)}</div>`;
      switchToTab("tokens");
      btnScan.disabled = false;
      btnExtractTokens.disabled = false;
    }
  };

  btnFillSpacingScale.onclick = () => {
    try {
      replaceSpacingScaleWithTokens(currentReportData.tokens);
    } catch (e) {
      console.error("Failed to fill spacing guidelines from tokens", e);
    }
  };

  // Helper function to calculate color brightness (0 = dark, 255 = bright)
  function getColorBrightness(hex) {
    // Remove # if present
    const cleanHex = hex.replace('#', '');
    
    // Parse RGB values
    const r = parseInt(cleanHex.substring(0, 2), 16);
    const g = parseInt(cleanHex.substring(2, 4), 16);
    const b = parseInt(cleanHex.substring(4, 6), 16);
    
    // Calculate perceived brightness using standard formula
    // Human eye is more sensitive to green, then red, then blue
    return (r * 299 + g * 587 + b * 114) / 1000;
  }

  btnFillColorScale.onclick = () => {
    try {
      const tokens = currentReportData.tokens;
      if (!tokens || !Array.isArray(tokens.colors) || !tokens.colors.length) {
        alert("No color tokens found. Please run 'Extract Design Tokens' first.");
        return;
      }

      const input = document.getElementById("color-scale");
      if (!input) return;

      const list = tokens.colors || [];
      // Extract hex values and ensure uppercase for consistency
      const values = list
        .map(t => String(t && t.value !== undefined ? t.value : "").trim().toUpperCase())
        .filter(v => v && v.startsWith("#"));

      if (!values.length) return;
      
      // Remove duplicates and sort by brightness (dark to light: #000000 ‚Üí #FFFFFF)
      const uniqueValues = Array.from(new Set(values)).sort((a, b) => {
        return getColorBrightness(a) - getColorBrightness(b);
      });
      input.value = uniqueValues.join(", ");

      // Render color preview after filling
      if (typeof renderColorPreview === "function") renderColorPreview();

      // Visual feedback
      try {
        input.focus();
        input.setSelectionRange(input.value.length, input.value.length);
      } catch (e) {
        // ignore
      }
    } catch (e) {
      console.error("Failed to fill color from tokens", e);
    }
  };

  // Extract Color Styles from Figma
  btnExtractColorStyles.onclick = () => {
    // Request color styles from Figma
    parent.postMessage({ pluginMessage: { type: "extract-color-styles" } }, "*");
  };

  const btnExtractColorVariables = document.getElementById("btn-extract-color-variables");
  if (btnExtractColorVariables) {
    btnExtractColorVariables.onclick = () => {
      // Request color variables from Figma
      parent.postMessage({ pluginMessage: { type: "extract-color-variables" } }, "*");
    };
  }

  btnFillFontSizeScale.onclick = () => {
    try {
      const tokens = currentReportData.tokens;
      if (!tokens || !Array.isArray(tokens.fontSize) || !tokens.fontSize.length) {
        alert("No font size tokens found. Please run 'Extract Design Tokens' first.");
        return;
      }

      const input = document.getElementById("font-size-scale");
      if (!input) return;

      // Extract unique font sizes and sort
      const values = tokens.fontSize
        .map(t => parseInt(String(t && t.value !== undefined ? t.value : "").trim(), 10))
        .filter(n => !isNaN(n));

      if (!values.length) return;

      const uniqueSorted = Array.from(new Set(values)).sort((a, b) => b - a); // Descending for font sizes
      input.value = uniqueSorted.join(", ");

      // Visual feedback
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
    } catch (e) {
      console.error("Failed to fill font size from tokens", e);
    }
  };

  btnFillLineHeightScale.onclick = () => {
    try {
      const tokens = currentReportData.tokens;
      if (!tokens || !Array.isArray(tokens.lineHeight) || !tokens.lineHeight.length) {
        alert("No line height tokens found. Please run 'Extract Design Tokens' first.");
        return;
      }

      const input = document.getElementById("line-height-scale");
      if (!input) return;

      // Extract unique line heights and sort
      const values = [];
      tokens.lineHeight.forEach(t => {
        const value = String(t && t.value !== undefined ? t.value : "").trim();
        if (value === "auto") {
          values.push("auto");
        } else {
          const numValue = parseFloat(value);
          if (!isNaN(numValue)) {
            values.push(numValue);
          }
        }
      });

      if (!values.length) return;

      // Separate auto and numeric values
      const hasAuto = values.includes("auto");
      const numericValues = values.filter(v => v !== "auto");
      const uniqueSorted = Array.from(new Set(numericValues)).sort((a, b) => a - b); // Ascending

      // Combine: auto first, then sorted numeric
      const finalValues = hasAuto ? ["auto", ...uniqueSorted] : uniqueSorted;
      input.value = finalValues.join(", ");

      // Visual feedback
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
    } catch (e) {
      console.error("Failed to fill line height from tokens", e);
    }
  };

  // Use Typography for Font Size
  btnFillFontSizeFromTypo.onclick = () => {
    try {
      if (!typographyStyles || !Array.isArray(typographyStyles) || typographyStyles.length === 0) {
        alert("No typography styles defined. Please add typography styles or extract from Figma first.");
        return;
      }

      const input = document.getElementById("font-size-scale");
      if (!input) return;

      // Extract unique font sizes from typography styles
      const values = typographyStyles
        .map(style => {
          const size = parseInt(String(style.fontSize || "").trim(), 10);
          return isNaN(size) ? null : size;
        })
        .filter(v => v !== null);

      if (!values.length) {
        alert("No valid font sizes found in typography styles.");
        return;
      }

      const uniqueSorted = Array.from(new Set(values)).sort((a, b) => b - a); // Descending for font sizes
      input.value = uniqueSorted.join(", ");
      
      // Save and visual feedback
      saveInputValues();
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
      
      console.log("Filled font size from typography:", uniqueSorted);
    } catch (e) {
      console.error("Failed to fill font size from typography", e);
    }
  };

  // Use Typography for Line Height
  btnFillLineHeightFromTypo.onclick = () => {
    try {
      if (!typographyStyles || !Array.isArray(typographyStyles) || typographyStyles.length === 0) {
        alert("No typography styles defined. Please add typography styles or extract from Figma first.");
        return;
      }

      const input = document.getElementById("line-height-scale");
      if (!input) return;

      // Extract unique line heights from typography styles
      const values = [];
      typographyStyles.forEach(style => {
        const lh = String(style.lineHeight || "").trim();
        if (lh === "auto") {
          values.push("auto");
        } else {
          // Handle both percentage (120%) and numeric (1.5)
          const numValue = parseFloat(lh.replace("%", ""));
          if (!isNaN(numValue)) {
            values.push(numValue);
          }
        }
      });

      if (!values.length) {
        alert("No valid line heights found in typography styles.");
        return;
      }

      // Separate auto and numeric values
      const hasAuto = values.includes("auto");
      const numericValues = values.filter(v => v !== "auto");
      const uniqueSorted = Array.from(new Set(numericValues)).sort((a, b) => a - b); // Ascending

      // Combine: auto first, then sorted numeric
      const finalValues = hasAuto ? ["auto", ...uniqueSorted] : uniqueSorted;
      input.value = finalValues.join(", ");
      
      // Save and visual feedback
      saveInputValues();
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
      
      console.log("Filled line height from typography:", finalValues);
    } catch (e) {
      console.error("Failed to fill line height from typography", e);
    }
  };

  // Typography Panel Toggle
  const typographyPanel = document.getElementById("typography-panel");
  const typographyPanelHeader = document.getElementById("typography-panel-header");
  const typographyPanelToggle = document.getElementById("typography-panel-toggle");
  
  if (typographyPanelHeader && typographyPanel && typographyPanelToggle) {
    typographyPanelHeader.onclick = () => {
      const isCollapsed = typographyPanel.classList.contains("collapsed");
      typographyPanel.classList.toggle("collapsed");
      
      // Update icon
      const icon = typographyPanelToggle.querySelector(".issue-group-toggle-icon");
      if (icon) {
        icon.textContent = isCollapsed ? "‚ñº" : "‚ñ∂";
      }
    };
  }

  // Render Color Preview Swatches
  function renderColorPreview() {
    const colorInput = document.getElementById("color-scale");
    const colorPreview = document.getElementById("color-preview");
    
    if (!colorInput || !colorPreview) return;
    
    const value = colorInput.value.trim();
    colorPreview.innerHTML = "";
    
    if (!value) return;
    
    // Parse colors (split by comma)
    const colors = value.split(",").map(c => c.trim()).filter(c => c);
    
    colors.forEach((color, index) => {
      // Validate color format (basic hex or rgba)
      const isValidHex = /^#[0-9A-Fa-f]{3,8}$/.test(color);
      const isValidRgba = /^rgba?\(/.test(color);
      
      if (!isValidHex && !isValidRgba) return; // Skip invalid colors
      
      // Create color swatch container
      const swatchContainer = document.createElement("div");
      swatchContainer.className = "color-swatch-container";
      
      // Create color swatch
      const swatch = document.createElement("div");
      swatch.className = "color-swatch";
      swatch.style.background = color; // Only set the dynamic background color
      
      // Add close button
      const closeBtn = document.createElement("button");
      closeBtn.innerHTML = "√ó";
      closeBtn.className = "color-swatch-close";
      
      closeBtn.onclick = function(e) {
        e.stopPropagation();
        // Remove this color from input
        const allColors = colorInput.value.split(",").map(c => c.trim()).filter(c => c);
        const newColors = allColors.filter((c, i) => i !== index);
        colorInput.value = newColors.join(", ");
        
        // Re-render and save
        renderColorPreview();
        if (typeof saveInputValues === "function") saveInputValues();
      };
      
      // Add label below swatch with color name and value (always visible)
      const colorHex = color.toUpperCase();
      const colorName = colorNameMap[colorHex];
      
      const label = document.createElement("div");
      label.className = "color-swatch-label";
      
      // Show "Name (Hex)" if name exists, otherwise just "Hex"
      if (colorName) {
        label.innerHTML = `
          <div class="color-swatch-label-name">${escapeHtml(colorName)}</div>
          <div class="color-swatch-label-hex">${escapeHtml(colorHex)}</div>
        `;
      } else {
        label.innerHTML = `<div class="color-swatch-label-hex">${escapeHtml(colorHex)}</div>`;
      }
      
      swatch.appendChild(closeBtn);
      swatchContainer.appendChild(swatch);
      swatchContainer.appendChild(label);
      colorPreview.appendChild(swatchContainer);
    });
  }

  // Get active rules
  function getActiveRules() {
    return {
      fontFamily: document.getElementById("rule-font-family")?.checked || false,
      fontSize: document.getElementById("rule-font-size")?.checked || false,
      fontWeight: document.getElementById("rule-font-weight")?.checked || false,
      lineHeight: document.getElementById("rule-line-height")?.checked || false,
      letterSpacing: document.getElementById("rule-letter-spacing")?.checked || false,
      wordSpacing: document.getElementById("rule-word-spacing")?.checked || false
    };
  }

  // Render Typography Table
  function renderTypographyTable() {
    const tbody = document.getElementById("typography-table-body");
    const thead = document.querySelector("#typography-table thead tr");
    if (!tbody || !thead) return;

    const activeRules = getActiveRules();

    // Build table headers based on active rules (Actions first)
    let headers = '<th class="typography-table-actions">Actions</th>';
    headers += '<th class="typography-table-style-name" style="width: 120px;">Style Name</th>';
    if (activeRules.fontFamily) headers += '<th class="typography-table-font-family" style="width: 140px;">Font Family</th>';
    if (activeRules.fontSize) headers += '<th class="typography-table-font-size" style="width: 80px;">Size (px)</th>';
    if (activeRules.fontWeight) headers += '<th class="typography-table-font-weight" style="width: 100px;">Weight</th>';
    if (activeRules.lineHeight) headers += '<th class="typography-table-line-height" style="width: 100px;">Line Height</th>';
    if (activeRules.letterSpacing) headers += '<th class="typography-table-letter-spacing" style="width: 100px;">Letter Spacing</th>';
    if (activeRules.wordSpacing) headers += '<th class="typography-table-word-spacing" style="width: 100px;">Word Spacing</th>';
    thead.innerHTML = headers;

    if (typographyStyles.length === 0) {
      const colspanCount = Object.values(activeRules).filter(v => v).length + 2; // +2 for name and actions
      tbody.innerHTML = `
        <tr>
          <td colspan="${colspanCount}" class="typography-empty-message">
            No typography styles defined. Click "Add Typography Style" to create one.
          </td>
        </tr>
      `;
      return;
    }

    tbody.innerHTML = typographyStyles.map(style => {
      let row = `<tr data-id="${style.id}">`;
      
      // Actions column first
      row += `<td class="typography-table-actions">`;
      
      // Add select button if styleId exists
      if (style.styleId) {
        row += `<button class="btn-table-action" onclick="selectTypographyStyle('${style.styleId}')" title="Select layer in Figma" style="background: #0071e3; color: white;">üëÅ</button>`;
      }
      
      row += `<button class="btn-table-action delete" onclick="deleteTypographyStyle(${style.id})" title="Delete">üóë</button>
        </td>`;
      
      // Style Name
      row += `<td><input type="text" value="${escapeHtml(style.name)}" data-field="name"></td>`;
      
      if (activeRules.fontFamily) {
        row += `<td><input type="text" value="${escapeHtml(style.fontFamily)}" data-field="fontFamily"></td>`;
      }
      
      if (activeRules.fontSize) {
        row += `<td><input type="number" value="${style.fontSize}" data-field="fontSize" min="1"></td>`;
      }
      
      if (activeRules.fontWeight) {
        row += `<td>
          <select data-field="fontWeight">
            <option value="Thin" ${style.fontWeight === "Thin" ? "selected" : ""}>Thin (100)</option>
            <option value="ExtraLight" ${style.fontWeight === "ExtraLight" ? "selected" : ""}>ExtraLight (200)</option>
            <option value="Light" ${style.fontWeight === "Light" ? "selected" : ""}>Light (300)</option>
            <option value="Regular" ${style.fontWeight === "Regular" ? "selected" : ""}>Regular (400)</option>
            <option value="Medium" ${style.fontWeight === "Medium" ? "selected" : ""}>Medium (500)</option>
            <option value="SemiBold" ${style.fontWeight === "SemiBold" ? "selected" : ""}>SemiBold (600)</option>
            <option value="Bold" ${style.fontWeight === "Bold" ? "selected" : ""}>Bold (700)</option>
            <option value="ExtraBold" ${style.fontWeight === "ExtraBold" ? "selected" : ""}>ExtraBold (800)</option>
            <option value="Black" ${style.fontWeight === "Black" ? "selected" : ""}>Black (900)</option>
          </select>
        </td>`;
      }
      
      if (activeRules.lineHeight) {
        row += `<td><input type="text" value="${escapeHtml(style.lineHeight)}" data-field="lineHeight" placeholder="120% or auto"></td>`;
      }
      
      if (activeRules.letterSpacing) {
        row += `<td><input type="text" value="${escapeHtml(style.letterSpacing || "0")}" data-field="letterSpacing" placeholder="0 or 0.5px"></td>`;
      }
      
      if (activeRules.wordSpacing) {
        row += `<td><input type="text" value="${escapeHtml(style.wordSpacing || "0")}" data-field="wordSpacing" placeholder="0"></td>`;
      }
      
      row += `</tr>`;
      
      return row;
    }).join("");

    // Add change listeners to auto-save
    tbody.querySelectorAll("input, select").forEach(input => {
      input.addEventListener("change", (e) => {
        const row = e.target.closest("tr");
        const id = parseInt(row.dataset.id);
        const field = e.target.dataset.field;
        const value = e.target.value;
        
        updateTypographyStyle(id, field, value);
      });
    });
  }

  // Add Typography Style
  window.addTypographyStyle = function() {
    const newStyle = {
      id: nextTypoStyleId++,
      name: "New Style",
      fontFamily: "Inter",
      fontSize: 16,
      fontWeight: "Regular",
      lineHeight: "150%",
      letterSpacing: "0",
      wordSpacing: "0"
    };
    typographyStyles.push(newStyle);
    renderTypographyTable();
    saveInputValues();
  };

  // Update Typography Style
  function updateTypographyStyle(id, field, value) {
    const style = typographyStyles.find(s => s.id === id);
    if (style) {
      if (field === "fontSize") {
        style[field] = parseInt(value) || 16;
      } else {
        style[field] = value;
      }
      saveInputValues();
    }
  }

  // Delete Typography Style
  window.deleteTypographyStyle = function(id) {
    if (!confirm("Delete this typography style?")) return;
    typographyStyles = typographyStyles.filter(s => s.id !== id);
    renderTypographyTable();
    saveInputValues();
  };

  window.selectTypographyStyle = function(styleId) {
    // Send message to backend to select the text style
    parent.postMessage({ pluginMessage: { type: "select-text-style", styleId: styleId } }, "*");
  };

  // Add button handler
  const btnAddTypoStyle = document.getElementById("btn-add-typo-style");
  if (btnAddTypoStyle) {
    btnAddTypoStyle.onclick = () => addTypographyStyle();
  }

  const btnExtractTypoDesktop = document.getElementById("btn-extract-typo-desktop");
  if (btnExtractTypoDesktop) {
    btnExtractTypoDesktop.onclick = () => {
      parent.postMessage({ pluginMessage: { type: "extract-typography-styles", mode: "desktop" } }, "*");
    };
  }

  const btnExtractTypoTablet = document.getElementById("btn-extract-typo-tablet");
  if (btnExtractTypoTablet) {
    btnExtractTypoTablet.onclick = () => {
      parent.postMessage({ pluginMessage: { type: "extract-typography-styles", mode: "tablet" } }, "*");
    };
  }

  const btnExtractTypoMobile = document.getElementById("btn-extract-typo-mobile");
  if (btnExtractTypoMobile) {
    btnExtractTypoMobile.onclick = () => {
      parent.postMessage({ pluginMessage: { type: "extract-typography-styles", mode: "mobile" } }, "*");
    };
  }

  const btnExtractTypoAll = document.getElementById("btn-extract-typo-all");
  if (btnExtractTypoAll) {
    btnExtractTypoAll.onclick = () => {
      parent.postMessage({ pluginMessage: { type: "extract-typography-styles", mode: "all" } }, "*");
    };
  }

  const btnResetTypoTable = document.getElementById("btn-reset-typo-table");
  if (btnResetTypoTable) {
    btnResetTypoTable.onclick = () => {
      if (confirm("‚ö†Ô∏è Reset typography table to default styles?\n\nThis will:\n‚Ä¢ Clear all current styles\n‚Ä¢ Restore default H1-H6 and Body styles\n\nThis action cannot be undone.")) {
        // Reset to default styles
        typographyStyles = [
          { id: 1, name: "H1", fontFamily: "Inter", fontSize: 48, fontWeight: "Bold", lineHeight: "120%", letterSpacing: "0", wordSpacing: "0" },
          { id: 2, name: "H2", fontFamily: "Inter", fontSize: 36, fontWeight: "Bold", lineHeight: "130%", letterSpacing: "0", wordSpacing: "0" },
          { id: 3, name: "H3", fontFamily: "Inter", fontSize: 30, fontWeight: "Semi Bold", lineHeight: "130%", letterSpacing: "0", wordSpacing: "0" },
          { id: 4, name: "H4", fontFamily: "Inter", fontSize: 24, fontWeight: "Semi Bold", lineHeight: "140%", letterSpacing: "0", wordSpacing: "0" },
          { id: 5, name: "H5", fontFamily: "Inter", fontSize: 20, fontWeight: "Semi Bold", lineHeight: "140%", letterSpacing: "0", wordSpacing: "0" },
          { id: 6, name: "H6", fontFamily: "Inter", fontSize: 16, fontWeight: "Semi Bold", lineHeight: "150%", letterSpacing: "0", wordSpacing: "0" },
          { id: 7, name: "Body", fontFamily: "Inter", fontSize: 14, fontWeight: "Regular", lineHeight: "150%", letterSpacing: "0", wordSpacing: "0" }
        ];
        nextTypoStyleId = 8;
        renderTypographyTable();
        saveInputValues();
        alert("‚úÖ Typography table has been reset to default styles!");
      }
    };
  }

  // Initial render
  renderTypographyTable();

  // Add event listeners to rule checkboxes to re-render table
  const ruleCheckboxes = [
    "rule-font-family",
    "rule-font-size", 
    "rule-font-weight",
    "rule-line-height",
    "rule-letter-spacing",
    "rule-word-spacing"
  ];

  ruleCheckboxes.forEach(id => {
    const checkbox = document.getElementById(id);
    if (checkbox) {
      checkbox.addEventListener("change", () => {
        renderTypographyTable();
        saveInputValues();
      });
    }
  });

  // Add event listener for color-scale input to render color preview
  const colorScaleInputEl = document.getElementById("color-scale");
  if (colorScaleInputEl) {
    colorScaleInputEl.addEventListener("input", () => {
      renderColorPreview();
    });
    // Render initial preview
    renderColorPreview();
  }

        // Export functions
        function generateHTMLReport() {
          const { issues, tokens, timestamp } = currentReportData;
          const date = new Date(timestamp).toLocaleString('vi-VN');
          const pageName = "Design Review"; // Could get from Figma API if needed
          
          let html = `<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Design Review Report - ${date}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      color: #1d1d1f;
      background: #f5f5f7;
      padding: 40px 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 40px;
    }
    .header {
      border-bottom: 2px solid #e5e5e7;
      padding-bottom: 20px;
      margin-bottom: 30px;
    }
    .header h1 {
      font-size: 28px;
      color: #1d1d1f;
      margin-bottom: 8px;
    }
    .header .meta {
      color: #86868b;
      font-size: 14px;
    }
    .section {
      margin-bottom: 40px;
    }
    .section-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #1d1d1f;
      padding-bottom: 8px;
      border-bottom: 1px solid #e5e5e7;
    }
    .export-filter-group {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .export-filter-btn {
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      cursor: pointer;
    }
    .export-filter-btn.active {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }
    .stats {
      display: flex;
      gap: 16px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    .stat-card {
      padding: 16px 20px;
      border-radius: 8px;
      background: #f5f5f7;
      min-width: 120px;
    }
    .stat-card.error { background: #fee; color: #c33; }
    .stat-card.warn { background: #fff4e6; color: #d97706; }
    .stat-card .value {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .stat-card .label {
      font-size: 12px;
      text-transform: uppercase;
      opacity: 0.8;
    }
    .issue-group {
      margin-bottom: 24px;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      padding: 16px;
      background: #fff;
    }
    .issue-group-header {
      font-size: 16px;
      font-weight: 600;
      color: #1d1d1f;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
    }
    .issue-group-toggle {
      border: none;
      background: #f3f4f6;
      width: 24px;
      height: 24px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .issue-group-content {
      margin-top: 12px;
    }
    .issue-group.collapsed .issue-group-content {
      display: none;
    }
    .issue {
      padding: 12px 16px;
      margin-bottom: 8px;
      border-radius: 6px;
      border-left: 4px solid;
    }
    .issue.error {
      background: #fef2f2;
      border-left-color: #ef4444;
    }
    .issue.warn {
      background: #fffbeb;
      border-left-color: #f59e0b;
    }
    .issue-type {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .issue-message {
      font-size: 14px;
      margin-bottom: 4px;
    }
    .issue-node {
      font-size: 12px;
      color: #86868b;
      font-family: monospace;
      margin-top: 4px;
    }
    .token-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 12px;
    }
    .token-item {
      padding: 12px;
      background: #fafafa;
      border-radius: 6px;
      border: 1px solid #e5e5e7;
    }
    .token-value {
      font-family: monospace;
      font-size: 13px;
      margin-bottom: 4px;
    }
    .token-color-preview {
      display: inline-block;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #d1d1d6;
      vertical-align: middle;
      margin-right: 8px;
    }
    .token-color-type {
      display: inline-block;
      font-size: 10px;
      padding: 2px 6px;
      background: #667eea;
      color: white;
      border-radius: 4px;
      margin-left: 6px;
    }
    .token-node-count {
      font-size: 11px;
      color: #86868b;
      margin-top: 4px;
    }
    .token-empty-message {
      padding: 12px;
      font-size: 12px;
      color: #9ca3af;
      font-style: italic;
    }
    @media print {
      body { padding: 20px; }
      .container { box-shadow: none; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé® Design Review Report</h1>
      <div class="meta">Generated: ${date} | Page: ${pageName}</div>
    </div>`;

          if (issues && issues.length > 0) {
            const stats = {
              error: issues.filter(i => i.severity === "error").length,
              warn: issues.filter(i => i.severity === "warn").length,
              total: issues.length
            };

            const grouped = issues.reduce((acc, i) => {
              acc[i.type] = acc[i.type] || [];
              acc[i.type].push(i);
              return acc;
            }, {});

            html += `
    <div class="section">
      <h2 class="section-title">üìä Summary</h2>
      <div class="stats">
        ${stats.error > 0 ? `<div class="stat-card error"><div class="value">${stats.error}</div><div class="label">Errors</div></div>` : ''}
        ${stats.warn > 0 ? `<div class="stat-card warn"><div class="value">${stats.warn}</div><div class="label">Warnings</div></div>` : ''}
        <div class="stat-card"><div class="value">${stats.total}</div><div class="label">Total Issues</div></div>
      </div>
    </div>

    <div class="section">
      <h2 class="section-title">üîç Issues</h2>
      <div class="export-filter-group">
        <button class="export-filter-btn active" data-severity="all">All</button>
        <button class="export-filter-btn" data-severity="error">Errors</button>
        <button class="export-filter-btn" data-severity="warn">Warnings</button>
      </div>`;

            for (const [type, typeIssues] of Object.entries(grouped)) {
              const typeLabel = escapeHtml(getTypeDisplayName(type));
              html += `
      <div class="issue-group collapsed" data-type="${type}" data-label="${typeLabel}">
        <div class="issue-group-header">
          <button class="issue-group-toggle" type="button">+</button>
          <span>${typeLabel} (${typeIssues.length})</span>
        </div>
        <div class="issue-group-content">`;
              
              typeIssues.forEach(issue => {
                html += `
          <div class="issue ${issue.severity}">
            <div class="issue-type">${issue.severity.toUpperCase()}</div>
            <div class="issue-message">${escapeHtml(issue.message)}</div>
            ${issue.nodeName ? `<div class="issue-node">Node: ${escapeHtml(issue.nodeName)}</div>` : ''}
          </div>`;
              });
              
              html += `
        </div>
      </div>`;
            }

            html += `
    </div>`;
          }

          if (tokens) {
            html += `
    <div class="section">
      <h2 class="section-title">üé® Design Tokens</h2>`;

            const tokenGroups = {
              colors: { label: "Colors", values: tokens.colors || [] },
              gradients: { label: "Gradients", values: tokens.gradients || [] },
              borderRadius: { label: "Border Radius", values: tokens.borderRadius || [] },
              fontWeight: { label: "Font Weight", values: tokens.fontWeight || [] },
              lineHeight: { label: "Line Height (%)", values: tokens.lineHeight || [] },
              fontSize: { label: "Font Size", values: tokens.fontSize || [] },
              fontFamily: { label: "Font Family", values: tokens.fontFamily || [] }
            };

            for (const [key, group] of Object.entries(tokenGroups)) {
              html += `
      <div class="issue-group collapsed">
        <div class="issue-group-header">
          <button class="issue-group-toggle" type="button">+</button>
          <span>${group.label} (${group.values.length})</span>
        </div>
        <div class="issue-group-content">`;

              if (!group.values || group.values.length === 0) {
                html += `
          <div class="token-empty-message">No tokens in this group.</div>`;
                html += `
        </div>
      </div>`;
                continue;
              }

              html += `
          <div class="token-list">`;

              group.values.forEach(token => {
                const tokenValue = token.value;
                const nodeCount = token.nodes ? token.nodes.length : 0;
                const colorType = token.colorType || "";

                if (key === "colors") {
                  html += `
          <div class="token-item">
            <div class="token-value">
              <span class="token-color-preview" style="background-color: ${escapeHtml(tokenValue)}"></span>
              ${escapeHtml(tokenValue)}
              ${colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : ''}
            </div>
            ${nodeCount > 1 ? `<div class="token-node-count">Used in ${nodeCount} nodes</div>` : ''}
          </div>`;
                } else if (key === "gradients") {
                  html += `
          <div class="token-item">
            <div class="token-value">
              <span class="token-color-preview" style="background: ${escapeHtml(tokenValue)}"></span>
              ${escapeHtml(tokenValue)}
              ${colorType ? `<span class="token-color-type">${escapeHtml(colorType)}</span>` : ''}
            </div>
            ${nodeCount > 1 ? `<div class="token-node-count">Used in ${nodeCount} nodes</div>` : ''}
          </div>`;
                } else {
                  // Special note for Font Weight: include font-family breakdown
                  let extraNote = "";
                  if (key === "fontWeight") {
                    let list = Array.isArray(token.fontFamilies) ? token.fontFamilies : null;
                    if (!list) {
                      const counts = {};
                      const nodes = Array.isArray(token.nodes) ? token.nodes : [];
                      nodes.forEach(n => {
                        const fam = (n && n.fontFamily) ? String(n.fontFamily) : "Unknown";
                        counts[fam] = (counts[fam] || 0) + 1;
                      });
                      list = Object.entries(counts)
                        .map(([family, count]) => ({ family, count }))
                        .sort((a, b) => (b.count - a.count) || a.family.localeCompare(b.family));
                    }
                    if (Array.isArray(list) && list.length > 0) {
                      const items = list
                        .map(x => `${escapeHtml(x.family)} (${x.count})`)
                        .join("<br/>");
                      extraNote = `<div class="token-node-count" style="margin-top: 6px;">Font-family:<br/>${items}</div>`;
                    }
                  }
                  html += `
          <div class="token-item">
            <div class="token-value">${escapeHtml(String(tokenValue))}</div>
            ${nodeCount > 1 ? `<div class="token-node-count">Used in ${nodeCount} nodes</div>` : ''}
            ${extraNote}
          </div>`;
                }
              });

              html += `
          </div>
        </div>
      </div>`;
            }

            html += `
    </div>`;
          }

          html += `
  </div>
  <script>
    (function() {
      function updateGroupState(group, content, toggleBtn) {
        const collapsed = group.classList.contains('collapsed');
        if (collapsed) {
          content.style.display = 'none';
          if (toggleBtn) toggleBtn.textContent = '+';
        } else {
          content.style.display = 'block';
          if (toggleBtn) toggleBtn.textContent = '‚àí';
        }
      }

      function initCollapsibles() {
        document.querySelectorAll('.issue-group').forEach(group => {
          const header = group.querySelector('.issue-group-header');
          const content = group.querySelector('.issue-group-content');
          const toggleBtn = group.querySelector('.issue-group-toggle');
          if (!content || !header) return;

          const toggle = () => {
            group.classList.toggle('collapsed');
            updateGroupState(group, content, toggleBtn);
          };

          if (toggleBtn) {
            toggleBtn.addEventListener('click', e => {
              e.stopPropagation();
              toggle();
            });
          }

          header.addEventListener('click', e => {
            if (toggleBtn && (e.target === toggleBtn || toggleBtn.contains(e.target))) {
              return;
            }
            toggle();
          });

          updateGroupState(group, content, toggleBtn);
        });
      }

      function applySeverityFilter(filter) {
        const buttons = document.querySelectorAll('.export-filter-btn');
        buttons.forEach(btn => {
          const val = btn.getAttribute('data-severity') || 'all';
          btn.classList.toggle('active', val === filter);
        });

        document.querySelectorAll('.issue-group').forEach(group => {
          const issues = group.querySelectorAll('.issue');
          const label = group.getAttribute('data-label') || '';
          let visibleCount = 0;

          issues.forEach(issue => {
            const isError = issue.classList.contains('error');
            const isWarn = issue.classList.contains('warn');
            let show = false;
            if (filter === 'all') show = true;
            else if (filter === 'error') show = isError;
            else if (filter === 'warn') show = isWarn;
            issue.style.display = show ? '' : 'none';
            if (show) visibleCount++;
          });

          const headerCountSpan = group.querySelector('.issue-group-header span:last-child');
          if (headerCountSpan && label) {
            headerCountSpan.textContent = label + ' (' + visibleCount + ')';
          }
        });
      }

      function initExportFilters() {
        const buttons = document.querySelectorAll('.export-filter-btn');
        if (!buttons.length) return;
        let current = 'all';

        buttons.forEach(btn => {
          btn.addEventListener('click', () => {
            const val = btn.getAttribute('data-severity') || 'all';
            current = val;
            applySeverityFilter(current);
          });
        });

        // Initial apply
        applySeverityFilter(current);
      }

      function initExportUI() {
        initCollapsibles();
        initExportFilters();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initExportUI);
      } else {
        initExportUI();
      }
    })();
  <\/script>
</body>
</html>`;

          return html;
        }

        // Scan history management - persisted via clientStorage through main plugin
        const MAX_HISTORY = 10;
        let scanHistoryMemory = [];
        let hasLoadedHistoryOnce = false;

        function saveScanHistory(mode, type, data, context) {
          try {
            if (type === "issues" && (!data.issues || data.issues.length === 0)) {
              console.log("Skipping save - no issues data");
              return;
            }
            if (type === "tokens" && (!data.tokens || Object.keys(data.tokens).length === 0)) {
              console.log("Skipping save - no tokens data");
              return;
            }

            const entry = {
              id: Date.now().toString(),
              mode,
              type,
              timestamp: new Date().toISOString(),
              context: context || null,
              data: {
                issues: data.issues || null,
                tokens: data.tokens || null,
                issuesCount: data.issues ? data.issues.length : 0,
                tokensCount: data.tokens ? Object.keys(data.tokens).reduce((sum, k) => sum + (data.tokens[k]?.length || 0), 0) : 0
              }
            };

            // Optimistically update local memory
            scanHistoryMemory.unshift(entry);
            scanHistoryMemory = scanHistoryMemory.slice(0, MAX_HISTORY);

            const historyPanel = document.getElementById("history-panel");
            if (historyPanel && historyPanel.style.display !== "none") {
              renderScanHistory();
            }

            parent.postMessage({ pluginMessage: { type: "save-history-entry", entry } }, "*");
          } catch (e) {
            console.error("Error saving scan history:", e);
          }
        }

        function requestScanHistory() {
          parent.postMessage({ pluginMessage: { type: "get-history" } }, "*");
        }

        function getScanHistory() {
          return scanHistoryMemory || [];
        }

        function loadLastScanMode() {
          try {
            const history = getScanHistory();
            if (history.length > 0) {
              const lastScan = history[0];
              const radio = document.querySelector(`input[name="scope"][value="${lastScan.mode}"]`);
              if (radio) {
                radio.checked = true;
                console.log("Loaded last scan mode:", lastScan.mode);
              }
            }
          } catch (e) {
            console.error("Error loading last scan mode:", e);
          }
        }

        function loadLastScanMode() {
          try {
            const history = getScanHistory();
            if (history.length > 0) {
              const lastScan = history[0];
              const radio = document.querySelector(`input[name="scope"][value="${lastScan.mode}"]`);
              if (radio) {
                radio.checked = true;
                console.log("Loaded last scan mode:", lastScan.mode);
              }
            }
          } catch (e) {
            console.error("Error loading last scan mode:", e);
          }
        }

        function formatHistoryTime(timestamp) {
          try {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return "Just now";
            if (diffMins < 60) return `${diffMins} minutes ago`;
            if (diffHours < 24) return `${diffHours} hours ago`;
            if (diffDays < 7) return `${diffDays} days ago`;
            
            return date.toLocaleString('en-US', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
          } catch (e) {
            return timestamp;
          }
        }

        function renderScanHistory() {
          const historyList = document.getElementById("history-list");
          if (!historyList) {
            console.error("history-list element not found");
            return;
          }

          const history = getScanHistory();
          console.log("Rendering scan history:", history.length, "entries");

          if (history.length === 0) {
            historyList.innerHTML = `
              <div class="history-empty">
                <div class="icon">üìã</div>
                <p>No scan history</p>
                <p style="font-size: 11px; margin-top: 8px;">Scans will be saved automatically</p>
              </div>
            `;
            return;
          }

          historyList.innerHTML = history.map(entry => {
            const timeStr = formatHistoryTime(entry.timestamp);
            const modeLabel = entry.mode === "page" ? "Page" : "Selection";
            const typeLabel = entry.type === "issues" ? "Issues" : "Tokens";
            const typeClass = entry.type === "issues" ? "issues" : "tokens";
            const contextLabel = (entry.context && entry.context.label) ? entry.context.label : `${modeLabel} scan`;
            
            let statsHtml = "";
            if (entry.type === "issues") {
              const errorCount = entry.data.issues?.filter(i => i.severity === "error").length || 0;
              const warnCount = entry.data.issues?.filter(i => i.severity === "warn").length || 0;
              statsHtml = `
                <span>‚ùå ${errorCount} errors</span>
                <span>‚ö†Ô∏è ${warnCount} warnings</span>
                <span>üìä ${entry.data.issuesCount} total</span>
              `;
            } else {
              statsHtml = `
                <span>üé® ${entry.data.tokensCount} tokens</span>
              `;
            }

            return `
              <div class="history-item" data-id="${entry.id}">
                <div class="history-item-header">
                  <span class="history-item-type ${typeClass}">${typeLabel}</span>
                  <span class="history-item-time">${timeStr}</span>
                </div>
                <div class="history-item-info">${escapeHtml(contextLabel)}</div>
                <div class="history-item-stats">${statsHtml}</div>
              </div>
            `;
          }).join("");

          // Add click handlers
          historyList.querySelectorAll(".history-item").forEach(item => {
            item.onclick = () => {
              const entryId = item.getAttribute("data-id");
              restoreReportFromHistory(entryId);
            };
          });
        }

        function restoreReportFromHistory(entryId) {
          try {
            const history = getScanHistory();
            const entry = history.find(e => e.id === entryId);
            
            if (!entry) {
              alert("Scan history entry not found!");
              return;
            }

            // Set scan mode
            const radio = document.querySelector(`input[name="scope"][value="${entry.mode}"]`);
            if (radio) {
              radio.checked = true;
            }
            currentReportData.scanMode = entry.mode;
            currentReportData.context = entry.context || null;

            // Restore report data
            if (entry.type === "issues" && entry.data.issues) {
              currentReportData.issues = entry.data.issues;
              currentReportData.tokens = null;
              isViewingTokens = false;
              renderResults(entry.data.issues, true, { restoreTimestamp: entry.timestamp });
            } else if (entry.type === "tokens" && entry.data.tokens) {
              currentReportData.issues = null;
              currentReportData.tokens = entry.data.tokens;
              isViewingTokens = true;
              renderTokens(entry.data.tokens, true, { restoreTimestamp: entry.timestamp });
            }

            // Close history panel
            const historyPanel = document.getElementById("history-panel");
            if (historyPanel) {
              historyPanel.style.display = "none";
            }

            console.log("Report restored from history:", entryId);
          } catch (e) {
            console.error("Error restoring report from history:", e);
            alert("Error restoring report: " + e.message);
          }
        }

        function exportReport(format) {
          if (!currentReportData.issues && !currentReportData.tokens) {
            alert("No data to export!");
            return;
          }

          // Format: design-review-report-YYYY-MM-DD-HH-MM-SS
          const now = new Date();
          const year = now.getFullYear();
          const month = String(now.getMonth() + 1).padStart(2, '0');
          const day = String(now.getDate()).padStart(2, '0');
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          const seconds = String(now.getSeconds()).padStart(2, '0');
          const filename = `design-review-report-${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;

          if (format === "html") {
            const html = generateHTMLReport();
            const blob = new Blob([html], { type: "text/html" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${filename}.html`;
            a.click();
            URL.revokeObjectURL(url);
          } else if (format === "pdf") {
            const html = generateHTMLReport();
            
            // Try to open print window
            try {
              const printWindow = window.open("", "_blank");
              
              if (!printWindow) {
                // Popup blocked - fallback to download HTML with print instructions
                alert("Popup blocked. Downloading HTML - you can open the file and select Print to create PDF.");
                const blob = new Blob([html], { type: "text/html" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `${filename}.html`;
                a.click();
                URL.revokeObjectURL(url);
                return;
              }
              
              // Write content to new window
              printWindow.document.open();
              printWindow.document.write(html);
              printWindow.document.close();
              
              // Wait for content to load, then trigger print
              printWindow.onload = () => {
                setTimeout(() => {
                  printWindow.print();
                }, 250);
              };
              
              // Fallback if onload doesn't fire
              setTimeout(() => {
                if (printWindow.document && printWindow.document.readyState === "complete") {
                  printWindow.print();
                }
              }, 500);
              
            } catch (error) {
              console.error("Error opening print window:", error);
              // Fallback: download HTML
              alert("Cannot open print window. Downloading HTML - you can open the file and select Print to create PDF.");
              const blob = new Blob([html], { type: "text/html" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = `${filename}.html`;
              a.click();
              URL.revokeObjectURL(url);
            }
          } else if (format === "json") {
            const json = JSON.stringify(currentReportData, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${filename}.json`;
            a.click();
            URL.revokeObjectURL(url);
          }
        }

        // Export button handlers
        const exportGroup = document.getElementById("export-group");
        const exportDropdown = document.getElementById("export-dropdown");
        
        btnExport.onclick = (e) => {
          e.stopPropagation();
          exportDropdown.style.display = exportDropdown.style.display === "block" ? "none" : "block";
        };

        document.querySelectorAll(".export-option").forEach(btn => {
          btn.onclick = (e) => {
            e.stopPropagation();
            const format = btn.getAttribute("data-format");
            exportReport(format);
            exportDropdown.style.display = "none";
          };
        });

        // Close dropdown when clicking outside
        document.addEventListener("click", (e) => {
          if (!exportGroup.contains(e.target)) {
            exportDropdown.style.display = "none";
          }
        });

  // Filter and search handlers - setup after DOM is ready
  let searchInput, btnClearSearch, filterButtons, colorTypeSelect;

  function applyFilters() {
    console.log("applyFilters called", { 
      isViewingTokens, 
      hasTokens: !!currentReportData.tokens, 
      hasIssues: !!currentReportData.issues,
      currentFilter,
      currentSearch,
      currentColorTypeFilter
    });
    if (isViewingTokens && currentReportData.tokens) {
      console.log("Applying filters to tokens");
      renderTokens(currentReportData.tokens, false); // Don't reset filters
    } else if (currentReportData.issues) {
      console.log("Applying filters to issues");
      renderResults(currentReportData.issues, false); // Don't reset filters
    }
  }

  function setupFilterHandlers() {
    console.log("setupFilterHandlers called");
    searchInput = document.getElementById("search-input");
    btnClearSearch = document.getElementById("btn-clear-search");
    filterButtons = document.querySelectorAll(".filter-btn");
    colorTypeSelect = document.getElementById("color-type-select");

    console.log("Elements found:", {
      searchInput: !!searchInput,
      btnClearSearch: !!btnClearSearch,
      filterButtons: filterButtons ? filterButtons.length : 0,
      colorTypeSelect: !!colorTypeSelect
    });

    if (!searchInput || !btnClearSearch || !filterButtons || filterButtons.length === 0) {
      console.warn("Filter elements not found, retrying...", {
        searchInput: !!searchInput,
        btnClearSearch: !!btnClearSearch,
        filterButtons: filterButtons ? filterButtons.length : 0
      });
      setTimeout(setupFilterHandlers, 100);
      return;
    }

    // Search input handler
    console.log("Setting up search input handler");
    searchInput.addEventListener("input", (e) => {
      const newValue = e.target.value;
      console.log("Search input changed:", newValue);
      currentSearch = newValue;
      console.log("currentSearch set to:", currentSearch);
      if (btnClearSearch) {
        btnClearSearch.style.display = currentSearch.trim() ? "block" : "none";
      }
      applyFilters();
    });

    // Clear search button
    if (btnClearSearch) {
      console.log("Setting up clear search button handler");
      btnClearSearch.onclick = (e) => {
        console.log("Clear search clicked");
        e.preventDefault();
        e.stopPropagation();
        if (searchInput) {
          searchInput.value = "";
        }
        currentSearch = "";
        btnClearSearch.style.display = "none";
        applyFilters();
      };
    }

    // Filter buttons handler - toggle behavior
    console.log("Setting up filter buttons handlers, count:", filterButtons.length);
    filterButtons.forEach((btn, index) => {
      console.log(`Setting up filter button ${index}:`, btn.getAttribute("data-filter"));
      btn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const filterValue = btn.getAttribute("data-filter");
        const isCurrentlyActive = btn.classList.contains("active");
        console.log("Filter button clicked:", filterValue, "isActive:", isCurrentlyActive);
        
        if (isCurrentlyActive && filterValue !== "all") {
          // If clicking an active button (except "all"), toggle it off and set to "all"
          btn.classList.remove("active");
          currentFilter = "all";
          // Activate "all" button
          filterButtons.forEach(b => {
            if (b.getAttribute("data-filter") === "all") {
              b.classList.add("active");
            }
          });
        } else {
          // Normal behavior: activate clicked button
          filterButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          currentFilter = filterValue;
        }
        
        console.log("currentFilter set to:", currentFilter);
        applyFilters();
      };
    });

    // Color type filter handler
    if (colorTypeSelect) {
      console.log("Setting up color type select handler");
      colorTypeSelect.addEventListener("change", (e) => {
        console.log("Color type changed:", e.target.value);
        currentColorTypeFilter = e.target.value;
        applyFilters();
      });
    }

    console.log("Filter handlers setup complete");
  }

  // Setup handlers when DOM is ready
  console.log("Setting up filter handlers, DOM readyState:", document.readyState);
  if (document.readyState === "loading") {
    console.log("DOM still loading, waiting for DOMContentLoaded");
    document.addEventListener("DOMContentLoaded", () => {
      console.log("DOMContentLoaded fired, setting up handlers");
      setupFilterHandlers();
      loadLastScanMode(); // Load last scan mode
      restoreLastReport(); // Restore last report if available
      restoreInputValues(); // Restore input values
      requestScanHistory(); // Fetch persisted history
    });
  } else {
    console.log("DOM already ready, setting up handlers immediately");
    setupFilterHandlers();
    loadLastScanMode(); // Load last scan mode
    restoreLastReport(); // Restore last report if available
    restoreInputValues(); // Restore input values
    requestScanHistory(); // Fetch persisted history
  }

  // History panel handlers
  if (btnHistory) {
    // Cancel Scan button
    btnCancelScan.onclick = () => {
      console.log("Cancel operation clicked");
      parent.postMessage({ pluginMessage: { type: "cancel-scan" } }, "*");
      // Reset UI state immediately (show both buttons, hide cancel/progress)
      btnScan.style.display = "block";
      btnScan.disabled = false;
      btnExtractTokens.style.display = "block";
      btnExtractTokens.disabled = false;
      btnCancelScan.style.display = "none";
      scanProgress.style.display = "none";
    };

    // Reset All button
    btnResetAll.onclick = () => {
      if (confirm("‚ö†Ô∏è Are you sure you want to reset all settings to default and clear history?\n\nThis will:\n‚Ä¢ Reset all input values to default\n‚Ä¢ Clear scan history\n‚Ä¢ Clear current reports\n\nThis action cannot be undone.")) {
        // Reset all inputs to default
        document.getElementById("spacing-scale").value = "0, 4, 8, 12, 16, 24, 32, 40, 48, 64, 72, 80, 88, 96";
        document.getElementById("spacing-threshold").value = "100";
        document.getElementById("color-scale").value = "";
        document.getElementById("font-size-scale").value = "32, 24, 20, 18, 16, 14, 12";
        document.getElementById("font-size-threshold").value = "100";
        document.getElementById("line-height-scale").value = "auto, 100, 110, 120, 130, 140, 150, 160, 170";
        document.getElementById("line-height-threshold").value = "300";
        document.getElementById("line-height-baseline-threshold").value = "120";
        
        // Reset typography styles to default
        typographyStyles = [
          { id: 1, name: "H1", fontFamily: "Inter", fontSize: 48, fontWeight: "Bold", lineHeight: "120%", letterSpacing: "0", wordSpacing: "0" },
          { id: 2, name: "H2", fontFamily: "Inter", fontSize: 36, fontWeight: "Bold", lineHeight: "130%", letterSpacing: "0", wordSpacing: "0" },
          { id: 3, name: "H3", fontFamily: "Inter", fontSize: 30, fontWeight: "Semi Bold", lineHeight: "130%", letterSpacing: "0", wordSpacing: "0" },
          { id: 4, name: "H4", fontFamily: "Inter", fontSize: 24, fontWeight: "Semi Bold", lineHeight: "140%", letterSpacing: "0", wordSpacing: "0" },
          { id: 5, name: "H5", fontFamily: "Inter", fontSize: 20, fontWeight: "Semi Bold", lineHeight: "140%", letterSpacing: "0", wordSpacing: "0" },
          { id: 6, name: "H6", fontFamily: "Inter", fontSize: 16, fontWeight: "Semi Bold", lineHeight: "150%", letterSpacing: "0", wordSpacing: "0" },
          { id: 7, name: "Body", fontFamily: "Inter", fontSize: 14, fontWeight: "Regular", lineHeight: "150%", letterSpacing: "0", wordSpacing: "0" }
        ];
        nextTypoStyleId = 8;
        renderTypographyTable();
        
        // Reset typography rules
        document.getElementById("rule-typo-style").checked = true;
        document.getElementById("rule-font-family").checked = true;
        document.getElementById("rule-font-size").checked = true;
        document.getElementById("rule-font-weight").checked = true;
        document.getElementById("rule-line-height").checked = true;
        document.getElementById("rule-letter-spacing").checked = false;
        document.getElementById("rule-word-spacing").checked = false;
        renderTypographyTable();
        
        // Render color preview after reset
        renderColorPreview();
        
        // Clear reports
        currentReportData = {
          issues: null,
          tokens: null,
          scanMode: null,
          timestamp: null,
          context: null,
          lastActiveTab: "issues"
        };
        clearResults("issues");
        clearResults("tokens");
        switchToTab("issues");
        
        // Clear history
        scanHistoryMemory = [];
        parent.postMessage({ pluginMessage: { type: "clear-history" } }, "*");
        
        // Re-render history panel to show empty state
        const historyPanel = document.getElementById("history-panel");
        if (historyPanel && historyPanel.style.display !== "none") {
          renderScanHistory();
        }
        
        // Save reset input values only (don't save report - it's already cleared in backend)
        saveInputValues();
        
        // Note: Don't call saveLastReport() here - backend already cleared it
        // and we want to keep it empty
        
        alert("‚úÖ All settings have been reset to default and history has been cleared!");
      }
    };

    btnHistory.onclick = () => {
      const historyPanel = document.getElementById("history-panel");
      if (historyPanel) {
        const isVisible = historyPanel.style.display !== "none";
        historyPanel.style.display = isVisible ? "none" : "flex";
        if (!isVisible) {
          renderScanHistory();
        }
      }
    };
  }

  if (btnCloseHistory) {
    btnCloseHistory.onclick = () => {
      const historyPanel = document.getElementById("history-panel");
      if (historyPanel) {
        historyPanel.style.display = "none";
      }
    };
  }

  btnClose.onclick = () => {
    parent.postMessage({ pluginMessage: { type: "close" } }, "*");
  };

  // Receive report from plugin code
  window.onmessage = (event) => {
    console.log("Received message:", event.data);
    const msg = event.data.pluginMessage;

    if (msg && msg.type === "fix-issue-result") {
      // Show fix result message
      showFixMessage(msg.issueId, msg.message, msg.success);
      
      // If successful, hide the issue after 5 seconds
      if (msg.success) {
        setTimeout(() => {
          const issueEl = document.querySelector(`.issue[data-issue-id="${msg.issueId}"]`) ||
                         document.querySelector(`button.btn-fix[data-id="${msg.issueId}"]`)?.closest(".issue");
          if (issueEl) {
            issueEl.style.transition = "opacity 0.5s ease-out";
            issueEl.style.opacity = "0";
            setTimeout(() => {
              if (issueEl.parentNode) {
                issueEl.remove();
                // Update badge count
                const groupEl = issueEl.closest(".issue-group");
                if (groupEl) {
                  const badge = groupEl.querySelector(".badge");
                  if (badge) {
                    const currentCount = parseInt(badge.textContent) || 0;
                    const newCount = Math.max(0, currentCount - 1);
                    badge.textContent = newCount;
                    // Hide group if no issues left
                    if (newCount === 0) {
                      groupEl.style.display = "none";
                    }
                  }
                }
              }
            }, 500);
          }
        }, 5000);
      }
      return;
    }

    if (msg && msg.type === "create-text-style-result") {
      // Show create style result message
      showFixMessage(msg.issueId, msg.message, msg.success);
      
      // If successful, hide the issue after 5 seconds
      if (msg.success) {
        setTimeout(() => {
          const issueEl = document.querySelector(`.issue[data-issue-id="${msg.issueId}"]`) ||
                         document.querySelector(`button.btn-create-style[data-id="${msg.issueId}"]`)?.closest(".issue");
          if (issueEl) {
            issueEl.style.transition = "opacity 0.5s ease-out";
            issueEl.style.opacity = "0";
            setTimeout(() => {
              if (issueEl.parentNode) {
                issueEl.remove();
                // Update badge count
                const groupEl = issueEl.closest(".issue-group");
                if (groupEl) {
                  const badge = groupEl.querySelector(".badge");
                  if (badge) {
                    const currentCount = parseInt(badge.textContent) || 0;
                    const newCount = Math.max(0, currentCount - 1);
                    badge.textContent = newCount;
                    // Hide group if no issues left
                    if (newCount === 0) {
                      groupEl.style.display = "none";
                    }
                  }
                }
              }
            }, 500);
          }
        }, 5000);
      }
      return;
    }

    if (msg && msg.type === "figma-text-styles-loaded") {
      // Update dropdown menu with loaded styles
      const dropdownMenu = document.querySelector(`.style-dropdown-menu[data-issue-id="${msg.issueId}"]`);
      if (dropdownMenu) {
        if (msg.error) {
          dropdownMenu.innerHTML = `<div style="padding: 8px 12px; color: #dc3545; font-size: 12px;">Error: ${escapeHtml(msg.error)}</div>`;
        } else if (msg.styles && msg.styles.length > 0) {
          // Find the issue to get bestMatch
          const issueEl = dropdownMenu.closest(".issue");
          const issueId = issueEl ? issueEl.getAttribute("data-issue-id") : null;
          let bestMatchName = null;
          if (issueId) {
            // Try to find bestMatch from current report data
            if (currentReportData && currentReportData.issues) {
              const issue = currentReportData.issues.find(i => i.id === issueId);
              if (issue && issue.bestMatch) {
                bestMatchName = issue.bestMatch.name;
              }
            }
          }
          
          dropdownMenu.innerHTML = msg.styles.map(style => `
            <div class="style-dropdown-item" data-issue-id="${msg.issueId}" data-style-id="${style.id}" data-style-name="${escapeHtml(style.name)}" style="padding: 8px 12px; cursor: pointer; font-size: 12px; ${bestMatchName === style.name ? 'background: #e3f2fd; font-weight: 600;' : ''}" onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='${bestMatchName === style.name ? '#e3f2fd' : 'white'}'">
              ${escapeHtml(style.name)} ${bestMatchName === style.name ? '‚≠ê' : ''}
            </div>
          `).join('');
          
          // Attach click handlers
          dropdownMenu.querySelectorAll(".style-dropdown-item").forEach(item => {
            item.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              const styleId = item.getAttribute("data-style-id");
              const styleName = item.getAttribute("data-style-name");
              
              // Find issue
              const issueEl = dropdownMenu.closest(".issue");
              if (issueEl) {
                const issueId = issueEl.getAttribute("data-issue-id");
                if (currentReportData && currentReportData.issues) {
                  const issue = currentReportData.issues.find(i => i.id === issueId);
                  if (issue) {
                    // Create style object from Figma text style
                    const style = msg.styles.find(s => s.id === styleId);
                    if (style) {
                      dropdownMenu.style.display = "none";
                      handleApplyFigmaTextStyle(issue, style);
                    }
                  }
                }
              }
            };
          });
        } else {
          dropdownMenu.innerHTML = '<div style="padding: 8px 12px; color: #999; font-size: 12px;">No text styles found in Figma</div>';
        }
      }
      return;
    }

    if (msg && msg.type === "apply-typography-style-result") {
      // Show apply style result message
      showFixMessage(msg.issueId, msg.message, msg.success);
      
      // If successful, hide the issue after 5 seconds
      if (msg.success) {
        setTimeout(() => {
          const issueEl = document.querySelector(`.issue[data-issue-id="${msg.issueId}"]`) ||
                         document.querySelector(`button.btn-suggest-apply[data-id="${msg.issueId}"]`)?.closest(".issue");
          if (issueEl) {
            issueEl.style.transition = "opacity 0.5s ease-out";
            issueEl.style.opacity = "0";
            setTimeout(() => {
              if (issueEl.parentNode) {
                issueEl.remove();
                // Update badge count
                const groupEl = issueEl.closest(".issue-group");
                if (groupEl) {
                  const badge = groupEl.querySelector(".badge");
                  if (badge) {
                    const currentCount = parseInt(badge.textContent) || 0;
                    const newCount = Math.max(0, currentCount - 1);
                    badge.textContent = newCount;
                    // Hide group if no issues left
                    if (newCount === 0) {
                      groupEl.style.display = "none";
                    }
                  }
                }
              }
            }, 500);
          }
        }, 5000);
      }
      return;
    }

    if (msg && msg.type === "scan-progress") {
      // Update progress bar
      if (scanProgressBar && scanProgressText) {
        scanProgressBar.style.width = msg.progress + "%";
        scanProgressText.textContent = msg.progress + "%" + " (" + msg.current + "/" + msg.total + ")";
      }
      return;
    }

    if (msg && msg.type === "last-report") {
      if (msg.report) {
        applySavedReport(msg.report);
      } else {
        console.log("No last report stored");
      }
      return;
    }

    if (msg && msg.type === "history-data") {
      const history = Array.isArray(msg.history) ? msg.history.slice(0, MAX_HISTORY) : [];
      scanHistoryMemory = history;
      if (!hasLoadedHistoryOnce) {
        loadLastScanMode();
        hasLoadedHistoryOnce = true;
      }
      const historyPanel = document.getElementById("history-panel");
      if (historyPanel && historyPanel.style.display !== "none") {
        renderScanHistory();
      }
      return;
    }

    if (msg && msg.type === "input-values-data") {
      if (msg.values) {
        applyInputValues(msg.values);
        console.log("Restored input values:", msg.values);
      } else {
        console.log("No saved input values to restore");
      }
      return;
    }

    if (msg && msg.type === "report") {
            // Reset UI state
            btnScan.style.display = "block";
            btnScan.disabled = false;
            btnCancelScan.style.display = "none";
            scanProgress.style.display = "none";
            btnExtractTokens.disabled = false;
      const issues = msg.issues || [];
            
            currentReportData.context = msg.context || null;
            renderResults(issues);
            
            // Save to history after successful scan (with full data)
            const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";
            saveScanHistory(scope, "issues", { issues: issues }, msg.context || null);
          }
          if (msg && msg.type === "tokens-report") {
            // Reset UI state
            btnExtractTokens.style.display = "block";
            btnExtractTokens.disabled = false;
            btnCancelScan.style.display = "none";
            scanProgress.style.display = "none";
            btnScan.disabled = false;
            if (msg.error) {
              resultsTokens.innerHTML = `<div class="error-message">Error: ${escapeHtml(msg.error)}</div>`;
              switchToTab("tokens");
            } else {
              currentReportData.context = msg.context || null;
              renderTokens(msg.tokens);
              btnFillSpacingScale.disabled = !(msg.tokens && Array.isArray(msg.tokens.spacing) && msg.tokens.spacing.length > 0);
              btnFillColorScale.disabled = !(msg.tokens && Array.isArray(msg.tokens.colors) && msg.tokens.colors.length > 0);
              btnFillFontSizeScale.disabled = !(msg.tokens && Array.isArray(msg.tokens.fontSize) && msg.tokens.fontSize.length > 0);
              btnFillLineHeightScale.disabled = !(msg.tokens && Array.isArray(msg.tokens.lineHeight) && msg.tokens.lineHeight.length > 0);
              
              // Save to history after successful extract (with full data)
              const scope = document.querySelector('input[name="scope"]:checked')?.value || "page";
              saveScanHistory(scope, "tokens", { tokens: msg.tokens }, msg.context || null);
      }
    }

    if (msg && msg.type === "typography-styles-extracted") {
      if (msg.styles && Array.isArray(msg.styles) && msg.styles.length > 0) {
        const modeLabel = msg.mode === "desktop" ? "Desktop" : 
                         msg.mode === "tablet" ? "Tablet" : 
                         msg.mode === "mobile" ? "Mobile" : "All";
        
        // Clear existing styles and replace with extracted ones
        typographyStyles = msg.styles.map((style, index) => {
          return {
            id: index + 1,
            name: style.name,
            styleId: style.styleId, // Store styleId for "Select" button
            fontFamily: style.fontFamily,
            fontSize: style.fontSize,
            fontWeight: style.fontWeight,
            lineHeight: style.lineHeight,
            letterSpacing: style.letterSpacing || "0",
            wordSpacing: style.wordSpacing || "0"
          };
        });
        
        nextTypoStyleId = typographyStyles.length + 1;
        
        // Re-render table
        renderTypographyTable();
        
        // Save to storage
        saveInputValues();
        
        alert(`‚úÖ Successfully imported ${msg.styles.length} ${modeLabel} typography styles from Figma!\n\nStyles: ${msg.styles.map(s => s.name).join(", ")}`);
      } else {
        const modeLabel = msg.mode === "desktop" ? "Desktop" : 
                         msg.mode === "tablet" ? "Tablet" : 
                         msg.mode === "mobile" ? "Mobile" : "";
        alert(`‚ö†Ô∏è No ${modeLabel.toLowerCase()} text styles found in this Figma file.\n\nMake sure you have defined text styles in your design system.`);
      }
    }

    if (msg && msg.type === "color-styles-extracted") {
      if (msg.colors && Array.isArray(msg.colors) && msg.colors.length > 0) {
        const input = document.getElementById("color-scale");
        if (!input) return;

        // Extract unique hex colors
        const uniqueColors = Array.from(new Set(msg.colors.map(c => c.hex)));

        // Sort by brightness (dark to light)
        function getColorBrightness(hex) {
          const cleanHex = hex.replace("#", "");
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return (r * 299 + g * 587 + b * 114) / 1000;
        }

        const sortedColors = uniqueColors.sort((a, b) => {
          return getColorBrightness(a) - getColorBrightness(b);
        });

        // Build color name map for tooltips
        colorNameMap = {};
        msg.colors.forEach(c => {
          if (c.hex && c.name) {
            colorNameMap[c.hex.toUpperCase()] = c.name;
          }
        });

        input.value = sortedColors.join(", ");

        // Render color preview
        if (typeof renderColorPreview === "function") renderColorPreview();

        // Save to storage
        saveInputValues();

        // Visual feedback
        try {
          input.focus();
          input.setSelectionRange(input.value.length, input.value.length);
        } catch (e) {
          // ignore
        }

        alert(`‚úÖ Successfully imported ${msg.colors.length} color styles from Figma!\n\nColors: ${msg.colors.map(c => c.name + " (" + c.hex + ")").join(", ")}`);
      } else {
        alert("‚ö†Ô∏è No color styles found in this Figma file.\n\nMake sure you have defined color styles (paint styles) in your design system.");
      }
    }

    if (msg && msg.type === "color-variables-extracted") {
      if (msg.colors && Array.isArray(msg.colors) && msg.colors.length > 0) {
        const input = document.getElementById("color-scale");
        if (!input) return;

        // Extract unique hex colors
        const uniqueColors = Array.from(new Set(msg.colors.map(c => c.hex)));

        // Sort by brightness (dark to light)
        function getColorBrightness(hex) {
          const cleanHex = hex.replace("#", "");
          const r = parseInt(cleanHex.substring(0, 2), 16);
          const g = parseInt(cleanHex.substring(2, 4), 16);
          const b = parseInt(cleanHex.substring(4, 6), 16);
          return (r * 299 + g * 587 + b * 114) / 1000;
        }

        const sortedColors = uniqueColors.sort((a, b) => {
          return getColorBrightness(a) - getColorBrightness(b);
        });

        // Build color name map for tooltips
        colorNameMap = {};
        msg.colors.forEach(c => {
          if (c.hex && c.name) {
            colorNameMap[c.hex.toUpperCase()] = c.name;
          }
        });

        input.value = sortedColors.join(", ");

        // Render color preview
        if (typeof renderColorPreview === "function") renderColorPreview();

        // Save to storage
        saveInputValues();

        // Visual feedback
        try {
          input.focus();
          input.setSelectionRange(input.value.length, input.value.length);
        } catch (e) {
          // ignore
        }

        alert(`‚úÖ Successfully imported ${msg.colors.length} color variables from Figma!\n\nColors: ${msg.colors.map(c => c.name + " (" + c.hex + ")").join(", ")}`);
      } else {
        alert("‚ö†Ô∏è No color variables found in this Figma file.\n\nMake sure you have defined color variables in your design system.");
      }
    }
  };
})();
    </script>
  </body>
</html>
